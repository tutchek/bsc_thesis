\chapter{Introduction}
\thispagestyle{myheadings}\markright{$ $Id$ $}

\section{Motivation}
Constraint satisfaction is relatively new field of computer science which focus on the problems
which can be described by some constraints. As an example of constraint one can imagine logical dependencies 
(A is valid only if B is invalid), arithmetical constraints ($X = 8 + Y + Z$) and lots of more. Real life situations can 
be as well described with constraints, e.g. worker Smith cannot work with worker Adams, also he can work only 
on monday and tuesday and cannot work in the night shift. These constraints together defines whole
complex problem -- a Constraint Satisfaction Problem (\zkratka{CSP}{Constraint Satisfaction Problem}).
Further examples of CSP can be found in \cite{csplib} and \cite{Apt2003}.

In user guide to Choco there is written following fundamental sentence:

\begin{center}
\em If you know sudoku, then you know constraint programming.
\end{center}

There are many techiques how to solve CSP. One can use his own ad hoc created solution. 
Or there is availability of using some standard constraint solver. This solver expect
as an input description of problem and returns solution if some exists. There is many 
of these systems and this thesis pick some of them and test them in various aspects.
More complex list of solvers and other CSP related software is in \cite{bartak:los}.

The aspects which are studied are modelling capabilities, time and space efficiency, 
integration with other programming environments, development environment and debugging features. 

\section{Outline thesis}

In the second chapter we will study six solvers. All but one are open source solvers. 
The only commercial system is SICstus Prolog. ECLiPSE and SICstus Prolog are based on Prolog
programming language, Mozart on Oz language, Choco is a Java library, Gecode is based on C++ and finally 
minion is based on C language. Minion can be also used as standalone solver - in this 
case it provides its own language for definition of problems.

In the the third chapter we will define benchmarks and explain what the benchmarks
should show on the systems.

Fourth chapter contains detailed results of the benchmarks and finally in fifth chapter 
we will make some conclusions about the results.
