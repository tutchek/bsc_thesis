\section{Choco}
\verb= $Id$ =

Choco is a constraint solver which is implemented as a library in Java programming language.
It is distributed as a JAR package having a Javadoc documantation included. It is quite easy
to install it even for a beginners in Java and it lasts about five minutes in commonly used
IDEs. Since the Java is used, the Choco solver is available for various platforms
and operating systems. As far as it is not our goal to describe possibilities of host operating
system, we are not about to further discuss the Java features. Choco is being developed
at Ecole des Mines de Nantes ve Francii and it is freely available for downloading from 
SourceForge server. The main number of current version is 2. Choco divides the problem solution
into two parts -- a model and a solver itself. The model contains variables and constraints given 
in task. Afterwards, the solver is given the model as an input and it tries to find a solution. 
Variables in the model can be integers, real numbers or sets. Then the solver is able to
find a solution for the current model. A user can get information from the solver whether the 
problem has a solution or it contains a conflict. There is an interface for resolving solutions themselves, 
whereby one can ask for the first, the following or all existing solutions. If we define a variable
equal to a value of an objective function, the solver can this variable either minimize, or maximize.
Furthermore, the solver allow us to choose a strategy which might perfectly fit the given problem.
The variables of solver depends on the variables of the model and one can resolve values only through
the variables of the solver.

\subsection{Solver description}
As it has been already mentioned in the previous section, the solving of problem is divided
into two separated tasks -- to define a model and to deploy the model to a well-configured solver.
The model as well as the solver are classes, both of which are instanced by a user into objects.
First we describe the model and after that we look at the solver. 

\subsubsection{Model}
The model is a instance of class CPModel. In Choco the variables of the model are represented
as objects of the following types: IntegerVariable, RealVariable and SetVariable. Those 
variables, generally, are not created using the keyword new, but in Choco there are
factory methods for this purpose. One has to register those variables first by calling
a function CPModel::addVariable, or CPModel::addVariables when adding an array of variables at once.
While registering variables into a model, we can set additional properties to the variables, 
for example to set whether it is a decision variable, or a variable containing a result
of an objective function. It is not necessary to set those properties every time, however;
they might rapidly improve the computation. Alternatively, we can define those properties
in the solver, which way is described later in the following section.

Once we have registered the variables, a definition of constraints follows. It is possible
either to use a large number of build-in constraints, or to define our own constraints.
The constraints which are available natively in the solver are listed in the table [ADD TABLE].
Each of the constraint fits in one the following groups: basic constraints (true, false, relation operators),
basic expressions (goniometric functions, powers, sums), other constraints (\texttt{abs}, \texttt{div}, \texttt{max}, ...),
reified contraints ((\texttt{and}, \texttt{or}, \texttt{ifOnlyIf}) and global constraints (\texttt{allDifferent}, 
\texttt{occurenceMax}, ...). Furthermore, there are constraints available which might be used for modeling geometric constraints,
scheduling constraints and constraints for a sequention of variables which is accepted by finite automaton.



Vedle dodaných podmínek je mo¾né definovat podmínky vlastní. Jednou mo¾ností je 
definovat podmínku $p(x,y)$ jako mno¾inu kompatibilních hodnot $(a,b)$, tedy $p$ platí, 
pokud $x=a$ a $y=b$, pøípadnì jako mno¾inu nekompatibilních hodnot. Tato mno¾ina je zadaná 
jako tabulka hodnot. Vedle zadání tabulkou je mo¾né zadat podmínku jako predikát, 
který musí platit. Podmínka pak je tvoøena objektem typu podìdìného od tøídy BinRelation 
s implementovanou funkcí checkCouple. Tato funkce dostane jako parametry dvojici 
hodnot a vrátí bool hodnotu zda byla podmínka splnìna nebo ne. Vedle binárních 
podmínek je mo¾né specifikovat podmínky podobným stylem na n-ticích.  Pro v¹echny 
takové podmínky (jak binární tak n-ární) lze pak specifikovat po¾adovaný algoritmus 
hranové konzistence. K dispozici je AC3, AC2001, AC3rm, AC3 pro binární podmínky a 
AC32, AC3rm, AC2001 a AC2008 pro n-ární podmínky. Popis jednotlivých algoritmù mù¾ete 
nalézt v [najít citaci pro algoritmy AC].

\subsubsection{Øe¹iè}
Øe¹iè je objekt typu CPSolver, který se na základì modelu popsaného v pøedhoczí 
sekci pokusí najít øe¹ení. Øe¹iè nejprve pøeète promìnné modelu, které pøevede na 
promìnné øe¹ièe (IntegerVariable na IntDomainVar, RealVariable na RealVar a SetVariable 
na SetVar). Poté pøeète podmínky z modelu a vyrobí na jejich základì podmínky øe¹ièe. 
Øe¹iè poté pou¾ije vyhledávací strategii a hledá øe¹ení. Proto¾e je volba správné 
strategie klíèovým faktorem pro rychlost øe¹ení, je mo¾né nastavit její rùzné parametry. 
U¾ivatel si mù¾e zvolit tzv. selektor a iterátor. Selektor vybírá, kterou promìnnou 
vybrat k pøí¹tímu rozhodnutí solveru. Iterátor pak vybírá jednotlivé mo¾né hodnoty a 
iteruje pøes nì. Choco ve standardní distribucí nabízí základní selektory jako promìnnou 
s minimální doménou, promìnnou s maximální doménou apod. Iterátory pak mohou zkou¹et 
hodnoty v sestupném nebo vzestupném poøadí. Alternativou k iterátoru je selektor hodnoty, 
který na po¾ádání vrátí dal¹í mo¾nou hodnotu. Pro selektor hodnoty je mo¾né pou¾ít 
napøíklad minimální hodnotu domény, náhodnou hodnotu domény apod. Pro rùzné skupiny 
promìnných je mo¾né zvolit vlastní strategie tak, aby co nejlépe vystihovaly zadání 
problému. V tomto pøípadì se definuje chování øe¹ièe pomocí tzv. cílù. Cíl obsahuje 
definici strategie tzn. selektor nad danými promìnnými a iterátor nad hodnotami.

Proto¾e pøi øe¹ení rozsáhlých problémù mù¾e dojít k neúmìrnému èasu výpoètu, 
spotøebovaných systémových prostøedkù apod, lze definovat omezení na øe¹iè. Øe¹iè 
je mo¾né omezit èasem, poètem uzlù vyhledávacího stromu, hloubkou backtrackingu, 
poètem neúspì¹ných øe¹ení a nebo CPU èasem. U¾ivatel si mù¾e vedle tìchto limitù 
na øe¹ení nastavit vlastní limity.

Po pøeètení modelu a definici strategií pøichází samotné øe¹ení problému. Øe¹iè 
poskytuje interface jak pro iterování pøes øe¹ení (solve, nextSolution), tak pro 
získání v¹ech øe¹ení naráz. Dále øe¹iè umo¾òuje urèit promìnnou, kterou se pokusí 
minimalizovat/maximalizovat. Øe¹ení je ulo¾eno v promìnných øe¹ièe, ne v promìnných 
modelu, které byly u¾ivatelem definovány. Je tedy nutné promìnné øe¹ièe z øe¹ièe 
získat zavoláním funkce CPSolver::getVar která jako parametr pøijme promìnnou modelu 
a vrátí promìnnou øe¹ièe. 

\subsection{Nástroje pro podporu modelování}
Choco neobsahuje nástroj na grafickou visualisaci vyhledávacího stromu podobnì jako 
má napøíklad systémk Mozart nebo Gecode. Choco umo¾òuje vypsat log z prùbìhu øe¹ení. 
Logu se dají nastavit rùzné úrovnì podrobnosti od zcela tichého a¾ po kompletní výpis 
v¹ech událostí, které choco internì provádí. [Protyp pokud bude odpoved autoru zaporna] 
Mimo zmínìného logování u¾ivatel nemá k dispozici jiné debugovací nástroje jako napøíklad 
interaktivní procházení prohledávacího stromu a nebo zmínìnou visualisaci. [/prototyp]

\subsection{Subjektivní hodnocení solveru}
Solver Choco se ukázal jednoduchý na bì¾né pou¾ití. I èlovìk, které pøedtím 
nemìl zku¹enosti s javou, omezujícími podmínkami ani tímto solverem nemìl problém 
zaèít pou¾ívat solver a prakticky ho uplatnit. Systém je dobøe zdokumentován, i 
kdy¾ v dobì psaní této práce je dokumentace lehce nepøehledná. Pøesto v ní peèlivvý 
ètenáø najde zpravidla v¹e co potøebuje. Programátorská dokumentace je generovaná 
systémem JavaDoc. Díky tomu je ve vìt¹inì bì¾ných Java IDE u¾ivateli k dispozici 
ji¾ bìhem výbìru funkce pomocí intellisense, co¾ napomáhá rychlému pochopení øe¹ièe. 
Vývoj øe¹ièe je provozován na serveru SourceForge, je tedy jednoduchou standardní 
formou pøístup jak ke zdrojovým kódùm aplikace tak k historii skrze verzovací 
nástroj subversion. Na serveru sourceforge je také umístìné fórum technické 
podpory, ve kterém autoøi odpovídají na dotazy u¾ivatelù. Reakèní doba je velmi 
nízká a úroveò odpovìdí na takové úrovni, ¾e vìt¹ina problémù je rychle vyøe¹ena.
