\section{SICStus Prolog}

SICStus Prolog is an implementation of the Prolog programming language by Swedish
Institue of Computer Science or SICS. It differs from the other here discussed solvers 
because SICStus Prolog is not a free open source system. The trial version of this
system can be obtained. Just like the \eclipse system the SICStus Prolog is not only
a constraint solver but a programming language where constraint solver is shipped as 
an independent library. The system provides libraries for solving the constraint problems
over the finite domains, over the boolean domains and over the real domains.

\section{Solver description}
Simillary as in the \eclipse system the solvers are independent libraries shipped 
with the system. The constraint solver over the finite domain consist of the
{\em clp(fd)} library \cite{Carlsson97anopen-ended}. The language constructs are different
compared to \eclipse; however, the basic properties are preserved. Therefore porting
the \eclipse program to SICStus Prolog is not a hard work but also it is not trivial.
The number of available constraints is higher than the \eclipse system provides.
The clp(fd)library offers standard arithmetic expressions, the relation constraints
and the global constraints. The library also provides the scheduling constraints and 
the extensional constraints.

The {\em clp(b)} provides a solver over the boolean variables. The solver contains
the relation constraints as well as constraints for the tautology and satisfiability.
Finally the {\em clp(q,r)} library \cite{clpqr:opai} provides constraining over the 
rational and real numbers. The constraint solver for set variables is not available.

The standard set of constraints can be expanded by user defined constraints. As well as the
\eclipse system the SICStus Prolog offers to add constraints using the Constraint Handling
Rules language and FlatZinc language. User can also define his own constraints as the
Prolog predicate. The user created constraint can be either a global constraint or
a primitive constraint. The ways how to create such constraints are described in 
the SICStus Prolog manual.

\section{Debugging support}
The SICStus Prolog offers the {\em Finite Domain Constraint Debugger} or {\em fdbg} library.
This library can be used next to the standard Prolog debugging predicate \texttt{trace}. This
predicate allows to debug any prolog program. The {\em fdbg} library provides the
log of the constraint propagation and distribution. There are logged all changes to the
domains and other events which occured during the computation. The example of the {\em fdbg}
output is in the figure \ref{sicstus:fdbg}. On the first line there is a Prolog query.
We constrain the variable $X$ to be in the domain $\{5,...,9\}$ and the variable $Y$
to be in domain $\{1,...,6\}$. Then we constrain the variable $X$ to be smaller than
variable $Y$. We did not perform the search so the variables remains not solved.
User can set names for the variables to achieve a better orientation in the printout.
The library uses the following events which results in the action. The {\em constraint 
event} which is invoked when the global constraint is woken and the {\em labelling event}
which is called after the variable labeling is started or a variable gets constrained
or the labeling has failed. After such event eccurs the {\em visualiser} is called. 
The visualiser is a prolog predicate which typically shows the event in the user 
friendly format; however, it can do any action instead as a response to the event.
The primitive constraints are not tracked by {\em fdbg} but the arithmetical constraints
like $X \#< Y$ are changed to the global constraints when the library is loaded.
The user can specify the filename where the output of the {\em fdbg} will be written.

\begin{figure}
\caption{\label{sicstus:fdbg}The example of the {\em fdbg} output.}
\begin{verbatim}
| ?- X in 5..9, Y in 1..6, X #< Y.
<fdvar_9> in 5..9
    fdvar_9 = inf..sup -> 5..9
    Constraint exited.

<fdvar_10> in 1..6
    fdvar_10 = inf..sup -> 1..6
    Constraint exited.

<fdvar_9>+1#=<<fdvar_10>
    fdvar_9 = 5..9 -> {5}
    fdvar_10 = 1..6 -> {6}
    Constraint exited.
    
X in 4..6,
Y in 5..7 
\end{verbatim}   
\end{figure}

\subsection{Benchmarks implementation}
The implemented benchmarks in the SICStus Prolog are listed in the section \ref{implementation:sicstus}.
The solver is very similar to the one distributed with the \eclipse system. Therefore
the benchmarks were implemented in a very similar way. In fact we used the \eclipse source
code and modified them that they could be used in the SICStus Prolog. The main difference
between the systems is in the domain constraints and in the sum constraint.
The domain relation constraint in the \eclipse system is the operator \texttt{::/2}.
This predicate can be applied on the single variable as well as on the list.
The second operand is the domain in the form of a list of intervals. For example to constrain
the variable $X$ to be in the domain $\{1,2\}$ we use \texttt{X :: [1..2]}. 
In the SICStus Prolog one have to pay attention if the constraint
is used on the single variable or on the list of variables. In the first case the operator
\texttt{in/2} is used. The domain of the variable is the second operand. The domain 
can be specified as a single interval using the \texttt{../2} operator or using the set
expression. The expresion can contain the intervals connected using the set unions, 
set intersections or set complements. The list of variables can be constrained using
the \texttt{domain/3} predicate. The user specifies the lower and upper bound of the 
domain. The second change needed to get the correct SICStus Prolog source code was
determined by the \texttt{sum/3} predicate. In the \eclipse the \texttt{sum/1} predicate
takes a list as an argument and the return value can be used in the expression. In the SICStus Prolog
the sum is standard predicate and therefore it does not return a value. The predicate 
\texttt{sum(L, R, V)} instead posts the constraint $\sum{L} \sim_R V$, where L is a list,
R a relation, equality for example, and V is a variable. Example can be found in 
the magic sequence implementation in the section \ref{implementation:sicstus:ms} on
the line 17. The last change to the \eclipse implementation was the {\em implies} constraint.
We can use in the SICStus Prolog the equivalence constraint and therefore we used it.
Example of the equivalence constraint is in the SRQ implementation in the section \ref{implementation:sicstus:srq}
on line 39. The implementation of the SRQ problem also shows the problem with large
predicates. We had to split the \texttt{questions} predicate because it contained more than
256 variables. The optimalisation problem Location Warehouses is modelled also very
similar to the \eclipse system. The source code is in the section \ref{implementation:sicstus:warehouses}.
 
\subsection{Subjective description}
The SICStus Prolog is a profesional solution. The variety of available libraries 
is really large; however if iser need to solve constraint problem over the set variables 
it is useles. System is well documented and the manual is exhaustive. The system
is not available freely for the public use but the time limited trial version can
be acquired.