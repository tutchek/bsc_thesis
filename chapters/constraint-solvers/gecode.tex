\section{Gecode}
\verb= $Id$ =

Gecode is a C++ library for solving problems with constraints. It allows to
model a problem which contains integers, boolean variables and finite integer sets. Gecode
is a free open source software as many of the mentioned solvers are. The library is
distributed as source codes and for Windows OS there is also an installer with
pre-compiled libraries. Optionaly a user needs a Qt library, which is used in 
a visualization graphic tool Gist. Apart from basic constraints, Gecode has also 
constraints for scheduling, finite automatons, graphs and so on. We describe those
constraints further in the following section. Gecode often uses the feature of C++
to overload functions and operators, which leads to a fact that many equal constraints for
varying data types have the same name. In addition, the overloading of operators
helps to ease the work with expressions. A disadvantage might be a lack of explicit consciousness
about a state of used operators, therefore a user cannot be sure if an operator that is used 
for a variable is just a common operator, or a part of constraint. A key man of Gecode 
solver is Christian Schulte, who also participated in a development of the system Mozart/Oz. 

\subsection{Solver description}
A problem is modeled as a class derived from a class Space. In this particular class
there are defined variables and constraints. Variables are objects of one of the following type:
IntVar for integers, BoolVar for boolean variables and SetVar for finite integer sets. 
Compared to other solvers the boolean variables aren't just integers with a domain ${0,1}$.
It is not even allowed to declare a constraint $b=i$ having a boolean variable $b$ and an integer $i$.
When a relation between boolean and integer variable is required, one can use either reified constraints
($(i = 1) \Leftrightarrow b = 1$), or channelling constraints $b_i = j \Leftrightarrow i = j$ (such as $b = (0,0,0,1,0,0)$, $i = 3$).
The constrainst are global functions in a Gecode namespace, which have to be registered by a function \texttt{post}.
Due to the function overriding, most of the constraints are implemented in a way, 
where there are more variants each available through the overriding; and the appropriate one is chosen.
For example, one might want to use a constraint either with two variables or with one variable and 
a vector of variables. If user uses so-called {\em minimodel}, they can use short expressions,
for instance a constraint $a = x \cdot y$ can be written as \texttt{post(home, a == x*y )} instead of \texttt{mult(home,x,y,a)}; 
however, the minimodel works just as a "syntactic sugar" and, therefore, it does not come up 
with any new constraints and it only ease a way how the current ones are written. 

Apart from standard arithmetic constraints and order constraints, the Gecode offers
wide range of specialize constraints. For SAT there is a constraint \texttt{clause(space,rel,x,y,z)},
which is equal to a condition $\bigvee {x_i} \vee \bigvee{\neg y_i}$, respectively, $\bigwedge {x_i} \wedge \bigwedge{\neg y_i}$
depending on a param {\em rel}. There is another interesting constraint {\em count}, which 
quarantees that $\#\{i \in \{0, ..., |x|-1\}|x_i = j\} = y_j$ is satisfied. Which brings us to a fact,
that a benchmark Magic sequence can be modeled using one constraint \texttt{count(*this, x, x)}.
Moreover, there are also available extensional constraints. Those are constraints, which are 
defined using an extenstion, for example, a deterministic finite automata. In such a case, the constraint
has following pattern:  {\em $x$ is a word, which is accepted by automata $A$}. As for graph constraints, 
Gecode has a constraint {\em $x$ is a Hamilton circle}. For an area of scheduling, there is available
a constraint \texttt{cumulatives(home, resource, start, duration, end, height, limit, atmost)}, which
guarantees, that in a set of tasks T (task $T_i = \langle \mathrm{resource}_i, \mathrm{start}_i,
\mathrm{duration}_i, \mathrm{end}_i, \mathrm{height}_i \rangle$) it is used either up to $\mathrm{limit}$ of sources,
or at least the value depending on a param {\em atmost}. ???!!!???
zjistit pøesnou definici co to dìlá, nedává mi to moc smysl ???!!!???

A constraints set also contains following: standard set operations, constraints for cardinality of set and a constraint
which guarantees, that a weighed sum of set has a given value. That means if we have a set $x$, 
a weight vector $w$ and the total should be $y$, the coinstrant has a pattern $\sum{x_i w_i} = y$. 
Furthermore, there are two constraints available, both of which are related to convexity. A set is convexed, 
if it contains a continual interval of numbers. A set $\{1,2,3}$ is convex, but ${\1,2,3\}$ is not 
convex, since it does not contain number 2. Convex hull is the least convex superset. A constraint
\texttt{home,x} guarantees, that $x$ is convex and \texttt{home,x,y} means, that $y$ is a convex hull for $x$.

If one needs to model an optimalization problem, the problem representing class is derived from a class MaximizeScript
instead of a class Space. They define an override methods for cost, which returns its value for current model; 
afterwards an objective method is given such methods. Searching is maintained by
a function \texttt{branch(home,x,var,val)}, which set a search vector $x$. While distributing,
a param $var$ defines an algorithm for chosing a variable and a param $val$ defines an algorithm
for chosing of a value of variable on which depends the distribution. For the search of problem,
it is necessary to use following code: 

\begin{verbatim}
Model* m = new Model;	
SEARCH<Model> e(m);
delete m;

while (Model* s = e.next())
{
	s->print();
	delete s;
}  
\end{verbatim}

Model je tøída podìdìná od Space resp. MaximizeScript, která reprezentuje model CSP.
Místo {\em SEARCH} jenutné zadat konkrétní vyhledávací algoritmus. K dispozici je 
\texttt{DFS} -- depth-first left-most search, \texttt{LDS} -- limited discrepancy,
\texttt{BAB} -- branch-and-bound and finally \texttt{Restart} -- depth-first left-most
restart search. Algoritmy \texttt{BAB} a \texttt{Restart} se dají vyu¾ít pro hledání 
optimálního øe¹ení. V¹echny algoritmy podporují paralelní výpoèet. U¾ivatel tedy na
poèítaèi s více procesory mù¾e dosáhnout výraznì rychlej¹ího výpoètu.  

\subsection{Nástroje pro podporu modelování}
Pro zobrazení prohledávacího stromu nabízí Gecode nástroj Gist. Jedná se o nástroj velmi
podobný nástroji Explorer v øe¹ièi Mozart/Oz. Rozhraní, grafické symboly i funkce jsou
s Explorerem toto¾né. Funkce, kterou má Gist navíc je Gist node statistics, která
pro daný uzel prohledávacího stromu doká¾e zobrazit statistiku obsahující informace
o hloubce aktuálního uzlu vùèi koøenu stromu, aktuální vý¹ce podstromu daného uzlu 
a poètu úspì¹ných/neúspì¹ných øe¹ení v podstromu. Gist také obsahuje nástroj Inspector,
který funguje stejnì jako Inspector v Mozart/Oz.

\subsection{Subjektivní hodnocení solveru}
Gecode je typickým pøíkladem kvalitního software, který není rozumnì pøístupný u¾ivateli
kvùli absenci dokumentace. A¾ do verze 3.0.0, která vy¹la v bøeznu 2009 existovala pouze
programátorská dokumentace ve formátu doxygen. Ukázkové modely byly navíc obalené ¹ablonovou
tøídou example pro jejich snadnìj¹í spu¹tìní, ale pro samotné pochopení jak umístit 
øe¹iè do svého programu toto nestaèilo a bylo nutné prozkoumat dùkladnì zdrojové kódy øe¹ièe.
S verzí 3.0.0 vy¹la i elektronická kniha Modelling with Gecode \cite{gecode:modelling},
která toto zcela zmìnila. Jedná se o tutoriál, který krok po kroku provádí od základního 
po¾adavku -- z daného modelu vytvoøit zadání pro øe¹iè a¾ po ¹iroké mo¾nosti dal¹ího
nastavení øe¹ièe. Vedle klasické dokumentace existuje také emailová konference, která
je v dobì psaní této práce výborným místem pro kladení dotazù, na které zpravidla 
autoøi odpovídají ve velmi krátkém èase. 
