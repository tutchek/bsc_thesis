\section{Gecode}
\verb= $Id$ =

Gecode is a C++ library for solving problems with constraints. It allows to
model a problem which contains integers, boolean variables and finite integer sets. Gecode
is a free open source software as most of the mentioned solvers are. The library is
distributed as source and for Windows OS there is also an installer with
pre-compiled libraries. Optionally, a user needs a Qt library, which is used in 
a visualization graphic tool Gist. Apart from basic constraints, Gecode has also 
constraints for scheduling, finite automatons, graphs and so on. We describe those
constraints further in the following section. Gecode often uses the feature of C++
to overload functions and operators, which leads to a fact that many equal constraints for
various data types have the same name. In addition, the overloading of operators
helps to ease the work with expressions. A disadvantage might be a lack of explicit consciousness
about a state of used operators, therefore a user cannot be sure if an operator that is used 
for a variable is just a common operator, or a part of constraint. The most important person of Gecode 
solver is Christian Schulte, who also participated in a development of the system Mozart/Oz. 

\subsection{Solver description}
A problem is modeled as a class derived from a class Space. In this particular class
there are defined variables and constraints. The variables are objects of one of the following type:
IntVar for integers, BoolVar for boolean variables and SetVar for finite integer sets. 
Compared to other solvers the boolean variables aren't just integers with a domain ${0,1}$.
It is not even allowed to declare a constraint $b=i$ having a boolean variable $b$ and an integer $i$.
When a relation between boolean and integer variable is required, one can use either reified constraints
($(i = 1) \Leftrightarrow b = 1$), or channelling constraints $b_i = j \Leftrightarrow i = j$ (such as $b = (0,0,0,1,0,0)$, $i = 3$).
The constrainst are global functions in a Gecode namespace, which have to be registered by a function \texttt{post}.
Due to the function overriding, most of the constraints are implemented in a way, 
where there are more variants each available through the overriding; and the appropriate one is chosen.
For example, one might want to use a constraint either with two variables or with one variable and 
a vector of variables. If user uses so-called {\em minimodel}, they can use short expressions,
for instance a constraint $a = x \cdot y$ can be written as \texttt{post(home, a == x*y )} instead of \texttt{mult(home,x,y,a)}; 
however, the minimodel works just as a "syntactic sugar" and, therefore, it does not come up 
with any new constraints and it only ease a way how the current ones are written. 

Apart from standard arithmetic constraints and order constraints, the Gecode offers
wide range of specialize constraints. For SAT there is a constraint \texttt{clause(space,rel,x,y,z)},
which is equal to a condition $\bigvee {x_i} \vee \bigvee{\neg y_i}$, respectively, $\bigwedge {x_i} \wedge \bigwedge{\neg y_i}$
depending on a param {\em rel}. There is another interesting constraint {\em count}, which 
quarantees that $\#\{i \in \{0, ..., |x|-1\}|x_i = j\} = y_j$ is satisfied. Which brings us to a fact,
that a benchmark Magic sequence can be modeled using one constraint \texttt{count(*this, x, x)}.
Moreover, there are also available extensional constraints. Those are constraints, which are 
defined using an extenstion, for example, a deterministic finite automata. In such a case, the constraint
has following pattern:  {\em $x$ is a word, which is accepted by automata $A$}. As for graph constraints, 
Gecode has a constraint {\em $x$ is a Hamilton cycle}. For an area of scheduling, there is available
a constraint \texttt{cumulatives(home, resource, start, duration, end, height, limit, atmost)}, which
guarantees, that in a set of tasks T (task $T_i = \langle \mathrm{resource}_i, \mathrm{start}_i,
\mathrm{duration}_i, \mathrm{end}_i, \mathrm{height}_i \rangle$) it is used either up to $\mathrm{limit}$ of sources,
or at least the value depending on a param {\em atmost}. ???!!!???
zjistit pøesnou definici co to dìlá, nedává mi to moc smysl ???!!!???

A constraints set also contains following: standard set operations, constraints for cardinality of set and a constraint
which guarantees, that a weighed sum of set has a given value. That means if we have a set $x$, 
a weight vector $w$ and the total should be $y$, the coinstrant has a pattern $\sum{x_i w_i} = y$. 
Furthermore, there are two constraints available, both of which are related to convexity. A set is convexed, 
if it contains a continual interval of numbers. A set $\{1,2,3\}$ is convex, but $\{1,3,4,5\}$ is not 
convex, since it does not contain number 2. Convex hull is the least convex superset. A constraint
\texttt{home,x} guarantees, that $x$ is convex and \texttt{home,x,y} means, that $y$ is a convex hull for $x$.

If one needs to model an optimalization problem, the problem representing class is derived from a class MaximizeScript
instead of a class Space. They define an override methods for cost, which returns its value for current model; 
afterwards an objective method is given such methods. Searching is maintained by
a function \texttt{branch(home,x,var,val)}, which set a search vector $x$. While distributing,
a param $var$ defines an algorithm for chosing a variable and a param $val$ defines an algorithm
for chosing of a value of variable on which depends the distribution. For the search of problem,
it is necessary to use following code: 

\begin{verbatim}
Model* m = new Model;	
SEARCH<Model> e(m);
delete m;

while (Model* s = e.next())
{
	s->print();
	delete s;
}  
\end{verbatim}

A model is a class derived from a class Space or, respectively, MaximizeScript, which
represents a model of CSP. Instead of {\em SEARCH} it has to be given a specific search
algorithm. There are several algorithms available: \texttt{DFS} -- depth-first left-most search, \texttt{LDS} -- limited discrepancy,
\texttt{BAB} -- branch-and-bound and finally \texttt{Restart} -- depth-first left-most
restart search. Both algorithms \texttt{BAB} a \texttt{Restart} can be used when 
searching an optimal solution. All of the alforithms can be used for a parallel computation.
Having a computer with more CPUs, one can reach much faster computation.

\subsection{Debugging support}
In Gecode there is a tool Gist, which visualize a search tree. It is a tool quite 
similar to the tool Explorer in Mozart/Oz solver. The interface, graphic symbols and
functions are the same as in Explorer. On the other hand, Gist gives us an additional 
function Gist node statistics, which gives us more information about a specific node 
of the search tree, such as a depth of the node (according to a tree root), a current height
of the node's subtree and a number of successful/unsuccessful solutions in subtree.
In Gist there is also a tool Inspector, which works equally to the Inspector in Mozart/Oz.

\subsection{Subjective description}
Gecode is a typical example of a top software, which is not quite well usable due to
an absence of a documentation. Before the version 3.0.0, which was released in March 2009, there
was only a technical documentation generated by Doxygen. Furthermore, the example models where 
sealed into a pattern class Example so as to be easier to run; however, it lacked any further 
explanations how to implements the solver inside own project and it was necessary to deeply
examine the source code of the solver. With the new version 3.0.0 being released, there is
available also an e-book Modelling with Gecode \cite{gecode:modelling}, which fact has completely changed
the situtation. The e-book is a tutorial, which step by step guides the reader from a basic 
query -- from a given model construct a task for the solver -- to wide range of possibilities
of setting up the solver. Apart from the classic documention, there is also an e-mail conference,
which is -- while writing this thesis -- quite a great place to ask and where the authors
answer after a short period of time.
