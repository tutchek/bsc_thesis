\section{Gecode}
\verb= $Id$ =

Gecode is a C++ library for solving problems with constraints. It allows to
model a problem which contains integers, boolean variables and finite integer sets. Gecode
is a free open source software as most of the mentioned solvers are. The library is
distributed as source and for Windows OS there is also an installer with
pre-compiled libraries. Optionally, a user needs a Qt library, which is used in 
a visualization graphic tool Gist. Apart from basic constraints, Gecode has also 
constraints for scheduling, finite automatons, graphs and so on. We describe those
constraints further in the following section. Gecode often uses the feature of C++
to overload functions and operators, which leads to a fact that many equal constraints for
various data types have the same name. In addition, the overloading of operators
helps to ease the work with expressions. A disadvantage might be a lack of explicit consciousness
about a state of used operators, therefore a user cannot be sure if an operator that is used 
for a variable is just a common operator, or a part of constraint. The most important person of Gecode 
solver is Christian Schulte, who also participated in a development of the system Mozart/Oz. 

\subsection{Solver description}
A problem is modeled as a class derived from a class Space. In this particular class
there are defined variables and constraints. The variables are objects of one of the following type:
IntVar for integers, BoolVar for boolean variables and SetVar for finite integer sets. 
Compared to other solvers the boolean variables aren't just integers with a domain ${0,1}$.
It is not even allowed to declare a constraint $b=i$ having a boolean variable $b$ and an integer $i$.
When a relation between boolean and integer variable is required, one can use either reified constraints
($(i = 1) \Leftrightarrow b = 1$), or channelling constraints $b_i = j \Leftrightarrow i = j$ (such as $b = (0,0,0,1,0,0)$, $i = 3$).
The constrainst are global functions in a Gecode namespace, which have to be registered by a function \texttt{post}.
Due to the function overriding, most of the constraints are implemented in a way, 
where there are more variants each available through the overriding; and the appropriate one is chosen.
For example, one might want to use a constraint either with two variables or with one variable and 
a vector of variables. If user uses so-called {\em minimodel}, they can use short expressions,
for instance a constraint $a = x \cdot y$ can be written as \texttt{post(home, a == x*y )} instead of \texttt{mult(home,x,y,a)}; 
however, the minimodel works just as a "syntactic sugar" and, therefore, it does not come up 
with any new constraints and it only ease a way how the current ones are written. 

Apart from standard arithmetic constraints and order constraints, the Gecode offers
wide range of specialize constraints. For SAT there is a constraint \texttt{clause(space,rel,x,y,z)},
which is equal to a condition $\bigvee {x_i} \vee \bigvee{\neg y_i}$, respectively, $\bigwedge {x_i} \wedge \bigwedge{\neg y_i}$
depending on a param {\em rel}. There is another interesting constraint {\em count}, which 
guarantees that $\#\{i \in \{0, ..., |x|-1\}|x_i = j\} = y_j$ is satisfied. Which brings us to a fact,
that a benchmark Magic sequence can be modeled using one constraint \texttt{count(*this, x, x)}.
Moreover, there are also available extensional constraints. Those are constraints, which are 
defined using an extenstion, for example, a deterministic finite automata. In such a case, the constraint
has following pattern:  {\em $x$ is a word, which is accepted by automata $A$}. As for graph constraints, 
Gecode has a constraint {\em $x$ is a Hamilton cycle}. For an area of scheduling, there is available
a constraint \texttt{cumulatives(home, resource, start, duration, end, height, limit, atmost)}, which
guarantees, that in a set of tasks T (task $T_i = \langle \mathrm{machine}_i, \mathrm{start}_i,
\mathrm{duration}_i, \mathrm{end}_i, \mathrm{height}_i \rangle$) will be performed on 
the available machines. Each machine can handle at most $\mathrm{limit}_j$ tasks at
one moment.

The following constraints can be used for constraining of the set variables: standard set operations, constraints for cardinality of set and a constraint
which guarantees, that a weighed sum of set has a given value. That means if we have a set $x$, 
a weight vector $w$ and the total should be $y$, the coinstrant has a pattern $\sum{x_i w_i} = y$. 
Furthermore, there are two constraints available, both of which are related to convexity. A set is convexed, 
if it contains a continual interval of numbers. A set $\{1,2,3\}$ is convex, but $\{1,3,4,5\}$ is not 
convex, since it does not contain number 2. Convex hull is the least convex superset. A constraint
\texttt{home,x} guarantees, that $x$ is convex and \texttt{home,x,y} means, that $y$ is a convex hull for $x$.

If one needs to model an optimalization problem, the problem representing class is derived from a class MaximizeScript
instead of a class Space. They define an override methods for cost, which returns its value for current model; 
afterwards an objective method is given such methods. Searching is maintained by
a function \texttt{branch(home,x,var,val)}, which set a search vector $x$. While distributing,
a param $var$ defines an algorithm for chosing a variable and a param $val$ defines an algorithm
for chosing of a value of variable on which depends the distribution. For the search of problem,
it is necessary to use following code: 

\begin{verbatim}
Model* m = new Model;	
SEARCH<Model> e(m);
delete m;

while (Model* s = e.next())
{
	s->print();
	delete s;
}  
\end{verbatim}

A model is a class derived from a class Space or, respectively, MaximizeScript, which
represents a model of CSP. Instead of {\em SEARCH} it has to be given a specific search
algorithm. There are several algorithms available: \texttt{DFS} -- depth-first left-most search, \texttt{LDS} -- limited discrepancy,
\texttt{BAB} -- branch-and-bound and finally \texttt{Restart} -- depth-first left-most
restart search. Both algorithms \texttt{BAB} a \texttt{Restart} can be used when 
searching an optimal solution. All of the alforithms can be used for a parallel computation.
Having a computer with more CPUs, one can reach much faster computation.

\subsection{Debugging support}
In Gecode there is a tool Gist, which visualize a search tree. It is a tool quite 
similar to the tool Explorer in Mozart/Oz solver. The interface, graphic symbols and
functions are the same as in Explorer. On the other hand, Gist gives us an additional 
function Gist node statistics, which gives us more information about a specific node 
of the search tree, such as a depth of the node (according to a tree root), a current height
of the node's subtree and a number of successful/unsuccessful solutions in subtree.
In Gist there is also a tool Inspector, which works equally to the Inspector in Mozart/Oz.

\subsection{Benchmarks implementation}
All benchmarks are represented by the class derived from the base class Space except the
Locating Warehouses problem which is derived from the MinimizeSpace. The non-auxiliary
 constraint variables are member variables of the class. The constraints are posted in the 
 constructor. In the constructor there is also the call to the \texttt{branch} function which
 is used to tell the constraint solver over which variables should be the labelling algorithm
 used. To model most of the constraints we used the {\em minimodel} extension. That means that we could {\em post} the expressions
to the constraint store without having to explicitly set auxiliary variables and then
constrain them. All benchmarks except the Magic Sequence were transformed to the 
Gecode source very straightforward using the same structure of the constraint variables
and constraints as proposed in the chapter \ref{benchmarks}. For the magic sequence 
the solver offers the constraint \texttt{count} which itself representes the whole 
problem and therefore we used it. The Self Refferential Quiz in the section \ref{implementation:gecode:srq} 
was modelled using the boolean variables. The oly way how to constrain the boolean variables with
the integer constraints is by the \texttt{channel} constraint. This constraint among
the other possible actions can post a constraint $x = b$ where $x$ is an integer variable
and b is a boolean variable. Then we can constrain the integer variables and effects of 
these constraints applies on the boolean variables. This principle was used to ensure
that there is only one answer to each question on the lines 12--23. A lot of the
constraints in the SRQ problem have the form $(x \mand y \mand ... \mand \neg a \mand \neg b) \Leftrightarrow c$.
The standard boolean relation constraints could be used for this purpose; however, we use 
the \texttt{clause(space, rel, x,y,z)} constraint (line 37) which posts the constraint 
 $\bigvee {x_i} \vee \bigvee{\neg y_i} \Leftrightarrow z$, respectively, $\bigwedge {x_i} \wedge \bigwedge{\neg y_i} \Leftrightarrow z$.
 This constraint significantly reduces the number of the negation propagators.
 The optimalization problem need also call the \texttt{branch} function. Also the
 \texttt{cost} function has to be declared. Result of this function is used as a value of
 the objective function to find a better solution. The search engine for optimalization
 problems has to be \texttt{BAB} or \texttt{Restart}.
   

\subsection{Subjective description}
Gecode is a typical example of a top software, which is not quite well usable due to
an absence of a documentation. Before the version 3.0.0, which was released in March 2009, there
was only a technical documentation generated by Doxygen. Furthermore, the example models where 
sealed into a pattern class Example so as to be easier to run; however, it lacked any further 
explanations how to implements the solver inside own project and it was necessary to deeply
examine the source code of the solver. With the new version 3.0.0 being released, there is
available also an e-book Modelling with Gecode \cite{gecode:modelling}, which fact has completely changed
the situtation. The e-book is a tutorial, which step by step guides the reader from a basic 
query -- from a given model construct a task for the solver -- to wide range of possibilities
of setting up the solver. Apart from the classic documention, there is also an e-mail conference,
which is -- while writing this thesis -- quite a great place to ask and where the authors
answer after a short period of time.
