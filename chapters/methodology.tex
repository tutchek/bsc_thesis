\chapter{Methodology}
\thispagestyle{myheadings}\markright{$ $Id$ $}

In the introduction we explained what constraint solvers are and presented several examples of them. In the rest of the thesis we will focus on seven of them - ILOG OPL, SICStus Prolog, Mozart, ECLIPSE, Gecode, Choco and Minion. First two are professional commercial solutions the others are freely available open source products. Purpose of his thesis is to help new user with choosing the right solver. We tested solvers which use various programming languages and paradigms. Imperative paradigm is represented by C++ library Gecode and JAVA library Choco. For users experienced in logical programming might be interesting SICStus Prolog or ECLIPSE. Mozart is implementation of Oz which is multi-paradigm programming language. For these solvers user could use his existing experience and only learn API of the constraint library. The remaining solvers are configured by solver specific problem description language. This fact is advantage and disadvantage at once. As a disadvantage we must accept that user cannot use his experience with existing programming languages and has to learn new concepts. However specialized language for describing constraint problems can be more accessible for users which do not have programming experiences but needs to solve given problem.

We will examine all solvers using point of view of user experienced in given programming language but inexperienced in using of the solver. In case of OPL and Minion we will suspect that user is fully inexperienced.  The first examination will try to answer the question how difficult it is to learn using the solver. We will model problems described in the third chapter and look for constraints which cannot be modelled and describe possible solutions.  Important criterion is the quality of documentation. Solver can be the best of all but if the user cannot understand the usage it is useless. The quality of documentation is perceived subjectively and cannot be measured exactly. This means that any evaluation is only informational but should be considered. We will count as documentation the user guide, all other available guides, documents, web pages, doxygen style documentation. Availability of user forums or mailing list is also important part of learning of new system. We will mention some of them if there exists some for the solver.

When user masters the solver and uses it to solve real problems the time and space efficiency of used algorithms matters. Since OPL and SICStus are closed source we will not examine source codes and analyze its implementation. We will use models created in process described in previous paragraph. In \cite{fernandez00} authors sent models to the solvers authors and gave them chance to modify them to achieve the best performance of solvers. We will use our own models which are not perfect and tuned especially for particular solver. We will measure the time needed to load and time to solve the problem. If the solver cannot provide such information we will measure only total time. We will also measure amount of consumed memory during the program execution. All measurements will be performed several times and averaged to avoid randomness.
