\chapter{Constraint solvers}
\thispagestyle{myheadings}\markright{$ $Id$ $}

\section{Mozart/Oz}
Mozart je implementací multiparadigmatického jazyka Oz. Oz je funkcionální jazyk, 
který má vestavìnou podporu pro vícevláknové aplikace, podporu pro paralelizaci a 
mimo jiné obsahuje také vestavìnou podporu pro øe¹ené problémù s omezujícími podmínkami. 
Jak bylo zmínìno døíve, jde o jazyk multiparadigmatický, lze v nìm tedy psát i 
imperativní programy stejnì jako logické programy (podobné prologu). Dále je mo¾né 
definovat tøídy vèetnì dìdiènosti a praocvat s od nich odvozenými objekty. Tento 
jazyk byl navr¾en pro co nejvy¹¹í variabilitu pøi pou¾ití, proto¾e programátor 
mù¾e vyu¾ít naráz kombinaci funkctionálního, logického i imperativního programování, 
OOP a dal¹í najednou. Ve standardní distribuci je dodáván jako samostatný pøekladaè, 
který vytvoøí nativní programy pro daný operacní systém. Mimo toho umí také bì¾et 
v interaktivním módu, kdy se jednotlivé bloky pøíkazù posílají pøímo kompilátoru. 
Jako IDE se pou¾ívá bì¾nì systém EMACS, se kterým je Mozart/Oz dodáván. 

Podobnì jako v jiných funkcionálních jazycích je do promìnné mo¾né pøiøadit pouze 
jednu hodnotu za dobu jejího ¾ivota. Proto má ka¾dá promìnná vedle hodnoty je¹tì 
stav. V pøípadì, ¾e má dojít k akci nad promìnnou do které není nic pøiøazeno, aè 
by to pøíkaz vy¾adoval dojde k pozastavení vlákna dokud nebude do promìnné pøiøazeno. 
To umo¾òuje provést následující program:

\begin{verbatim}
a = 5
if a > b then c = 5 else c = 6
b = 4
// V c nyní bude hodnota 5
\end{verbatim}

Jazyk obsahuje vestavìnou podporu pro paralelní výpoèty, tedy na úrovni jazyka 
je mo¾né vytváøet vlákna a synchronizaèní primitiva. Jazyk navíc podporuje pøedat 
výpoèet na jiný poèítaè skrze protokol TCP/IP. Lze tedy vyu¾ít cluster poèítaèù 
pro zrychlení nároèných výpoètù.

\subsection{Popis øe¹ièe omezujících podmínek}
Pøo øe¹ení problémù s omezujícími podmínkami obsahuje vestavìný øe¹iè problémù s 
koneènou doménou (finite domain). Pro tyto úèely se mno¾inou s koneènou doménou 
rozumí koneèná mno¾ina pøirozených èísel s nulou. Øe¹iè obsahuje omezení na nejvy¹¹í 
mo¾nou hodnotu promìnné. Výpoèetní model pro propagaci podmínek se jmenuje prostor 
(space) a je tvoøen nìkolika propagátory napojenými na constraint store. Constraint 
store obsahuje konjunkci základních podmínek, tedy podmínek ve tvaru $x=n$ nebo $x \in 
D$. Tedy mù¾e vypadat napøíklad $x = 6 \& y \in 1 ... 12 \& z = y$. Propagátory 
obsahují ostatní podmínky, tedy napøíklad $x>y$ nebo $a^2 + b^2 = c^2$. Propagátor 
pro podmínku $c$ je samostatný výpoèetní agent, který se sna¾í omezit domény promìnných, 
které jsou obsa¾ené v $c$. Øe¹ením je pak takové pøiøazení hodnot promìnným, které 
splní v¹echny podmínky dané propagátory.

\begin{example} Mìjme promìnné $X$ a $Y$ a následující podmínky: $X \in \{0..9\}$, $Y \in \{0..9\}$, $X+Y = 9$, $2X + 4Y = 24$. 
\begin{enumerate}
  \item Constraint store obsahuje: $X \in \{0..9\}$, $Y \in \{0..9\}$. Propagátory: $X+Y = 9$ a $2X + 4Y = 24$.
  \item	První propagátor nemù¾e udìlat nic, druhý ale mù¾e zmìnit constraint store tak, ¾e obsahuje  $X \in \{0..8\}, Y \in \{2..6\}$.
  \item	První propagátor nyní mù¾e zmìnit constraint store na $X \in \{3..7\}$, $Y \in \{2..6\}$.
  \item	Druhý propagátor nyní zmìní constraint strore na $X \in \{4..6\}$, $Y \in 3..4$.
  \item	První propagátor zmìní constraint store na $X \in \{5..6\}$, $Y \in \{3..4\}$
  \item	Druhý propagátor nakonec zmìní constraint store, tak ¾e obsahuje $X = 6$, $Y = 3$.
\end{enumerate}
\end{example}

Propagace mù¾e být buï intervalová nebo doménová. Zatímco intervalová propagace 
pouze mìní okraje domény, doménová také odstraòuje vnitøní hodnoty domény. Pøesto¾e 
doménová propagace vypadá jako lep¹í techhnika, pou¾ívá se spí¹e intervalová pro její 
výpoèetní jednoduchost.

Ji¾ pro jednoduché problémy ale propagace nemusí vést k výsledku. Vezmìme napøíklad 
problém: $x \neq y$, $x \neq z$, $y \neq z$, $x \in \{0..1\}$, $y \in \{0..1\}$, $z \in \{0..1\}$. 
Tento problém nelze více propagovat, v¹echny podmínky lze splnit ale ¾ádná promìnné 
není pøiøazena hodnota. V této chvíli lze pou¾ít distribuci. Problém $P$ je distribuován 
pomocí podmínky $C$, pokud vyøe¹íme nové problémy $P \cup \{\neg C\}$ a $P\{C\}$. 
Alespoò v jednom z nových problémù se buï nachází øe¹ení problému $P$ a nebo je 
problém neøe¹itelný. V na¹í reprezentaci se tohoto faktu dá vyu¾ít pro space. 
Pokud se systém dostane do stabilního stavu, kdy ¾ádná podmínka není nesplnìna a 
pøitom není mo¾né pøiøadit ¾ádné promìnné hodnotu, tak vybereme promìnnou $x$ a 
hodnotu $n$ takovou, ¾e je konzistentní se v¹emi podmínkami nad $x$. Tím získáme 
dva nové space, jeden $S \cup {x = n}$ a jeden $S \cup {x \neq n}$. Na obou space 
pak pustíme propagaci. Pokud se dostane opìt do stabilního stavu, znova distribuujeme 
a takto postupujeme a¾ do vyøe¹ení problému a nebo konstatování, ¾e je problém 
neøe¹itelný. Tato metoda je úplná, tedy pokud existuje alespoò jedno øe¹ení, 
pak budou nalezena v¹echna.

Je mo¾né volit z rùzných distribuèních strategií. Volba správné strategie mù¾e 
výraznì ovlivnit dobu výpoètu. Pro vìt¹inu problémù je dobré zvolit first-fail 
strategii, tedy volit promìnnou s nejmen¹í mo¾nou doménou. Pokud ale ¾ádná dodávaná 
distribuèní strategie nevyhovuje, je mo¾né implementovat své distribuèní strategie, 
plnì na míru problému.

Pro hledání øe¹ení optimalizaèních problémù se dají vyu¾ít dvì techniky. Naivní 
technika spoèívá v postupném zvy¹ování výsledku objektivní  funkce a následném hledání 
øe¹ení, které tomuto výsledku bude odpovídat. Pro tento postup existuje v jazyce 
konstrukce, která pøed splòováním ostatních podmínek postupnì zvy¹uje danou promìnnou. 
Tento postup v¹ak postrádá obecnost a Mozart nabízí lep¹í postup -- techniku branch and bound. 
Tato technika vy¾aduje, aby u¾ivatel sestavil porovnávací funkci. Porovnávací funkce 
jako argumenty pøijímá pøedchozí a aktuální øe¹ení problému. Funkce pak zpravidla 
zavolá objektivní funkci a porovná její výsledky. Tato technika oproti naivní výraznì 
zrychlí výpoèet. 

\subsection{Nástroje pro podporu modelování}
Mozart nabízí u¾ivateli interaktivní nástroj Explorer, který umo¾òuje prozkoumat 
strom øe¹ení vèetnì dílèích rozhodnutí, které øe¹iè bìhem výpoètu uèinil. Explorer 
je mo¾né pou¾ívat také v interaktivním módu a ruènì urèovat, které vìtve øe¹ení prozkoumat. 
 
Koleèka oznaèují uzly rozhodovacího stromu, ve kterých probìhlo rozhodnutí, kosoètverce 
oznaèují nalezení úspì¹ného øe¹ení a ètverec vìtev kde není øe¹ení. Svìtlej¹í barvou 
jsou uvedené uzly, které je mo¾né je¹tì dále expandovat. Na uvedeném obrázku tedy 
máme jedno øe¹ení, dvì neúspì¹ná øe¹ení a pìt okam¾ikù, kdy do¹lo k rozhodnutí z 
nich¾ lze je¹tì ve tøech hledat dal¹í øe¹ení. Explorer umo¾òuje také export 
nakresleného stromu ve formátu PostScript.

\subsection{Implementace benchmarkù}
Ka¾dý implemetovaný benchmark je samostatný solver. Po zavolání pøíslu¹ného 
solveru je vrácena funkce, která je posléze pøedána funkci realizující hledání 
øe¹ení. Jde buï o funkce SearchOne resp. SearchAll, které naleznou jedno nebo 
v¹echna øe¹ení problému a vrátí je v seznamu. Pro spu¹tìní exploreru a interaktivní 
hledání øe¹ení lze pak zavolat ExploreOne resp. ExploreAll.

\section{Choco}
Choco je øe¹iè omezujících podmínek implementovaný jako knihovna pro programovací 
jazyk Java. Choco je distribuováno jako balíèek JAR s dokumentací ve formátu Javadoc. 
Instalace je tedy velmi snadná i pro zaèínajícího programátora v Javì a v bì¾nì 
pou¾ívaných IDE nezabere více ne¾ pìt minut. Díky programovacímu jazyku Java je 
solver Choco dostupný na mnoha platformách a operaèních systémech. Proto¾e ale 
není cílem této práce popisovat vlastnosti hostitelského programovacího jazyka, 
nebudeme zde dále rozebírat mo¾nosti Javy. Choco je vyvíjeno na Ecole des Mines 
de Nantes ve Francii a je volnì dostupné na serveru Sourceforge. Aktuální hlavní 
verze má èíslo 2. Choco dìlí øe¹eí problému na dvì èásti -- model a samotý øe¹iè. 
Model obsahuje promìnné a podmínky dané zadáním. Øe¹iè pak dostane na vstupu model 
a pokusí se v nìm najít øe¹ení. Model mù¾e obsahovat jako promìnné celá èísla, 
reálná èísla a mno¾iny. Øe¹iè je pak schopný k danému modelu najít øe¹ení. U¾ivatel 
mù¾e od øe¹ièe získat informaci, zda je problém øe¹itelný èi zda neobsahuje spor. 
Pro samotná øe¹ení poskytuje interface umo¾òující dotázat se na úrvní, následující 
a nebo na v¹echna øe¹ení. Pokud mu urèíme promìnnou s hodnotou objektivní funkce 
umo¾òuje øe¹iè tuto promìnnou minimalizovat nebo maximalizovat. Øe¹iè dále podporuje 
volbu strategií na míru øe¹enému problému. Promìnné modelu a øe¹ièe jsou ve vzájemném 
vztahu. Pøesto není mo¾é získat øe¹ení pøímo z promìnných modelu ale je nutné je 
získat pøes odpovídající promìnné øe¹ièe.

\subsection{Popis øe¹ièe omezujících podmínek}
Jak bylo naznaèeno v pøedchozí sekci, je øe¹ení problému rozdìleno na dva 
úkoly -- nadefinovat model a pøedlo¾it ho správnì nastavenému øe¹ièi. Jak model 
tak øe¹iè jsou tøídy, které si u¾ivatel instancuje do pøíslu¹ného objektu. 
Popí¹eme nejprve model a poté øe¹iè.

\subsubsection{Model}
Model  je tvoøen objektem tøídy CPModel. Promìnné modelu jsou v Choco reprezentovány 
objekty následujících typù IntegerVariable, RealVariable a SetVariable. Tyto promìnné 
se standardnì nevytváøení pomocí klíèového slova new, ale choco má pro tento úèel 
pøipravené tovární metody. Takovéto promìnné je nutné v modelu zaregistrovat pomocí 
funkce CPModel::addVariable resp. CPModel.addVariables (pro zaregistrování celého 
pole promìnných). Pøi registraci promìnné do modelu je mo¾né urèit dodateèné vlastnosti 
promìnných, napøíklad zda jde o decision promìnné, nebo o promìnnou obsahující výsledek 
objektivní funkce. Tyto vlastnosti není nutné v¾dy zadávat, ale mohou výraznì urychlit 
výpoèet. Alternativou je definovat si tyto vlastnosti v øe¹ièi. Toto bude popsáno v 
následující sekci.

Po zaregistrování promìnných následuje definice omezujících podmínek. Je mo¾né pou¾ít 
jak ¹irokou nabídku podmínek dodaných s øe¹ièem, tak si definovat vlastní podmínky. 
Podmínky dodané s øe¹ièem jsou vypsané v tabulce (tabulka). Lze je rozdìlit na základní 
podmínky (pravda, nepravda, operátory uspoøádání), a základní výrazy (goniometrické 
funkce, mocniny, sumy), ostatní podmínky (\texttt{abs}, \texttt{div}, \texttt{max}, ...), reifikované podmínky 
(\texttt{and}, \texttt{or}, \texttt{ifOnlyIf}) a globální podmínky (\texttt{allDifferent}, 
\texttt{occurenceMax}, ...). K dispozici 
jsou také podmínky pro modelování geometricých podmínek, podmínky pro rozvrhování a 
podmínky pro sekkvenci promìnných, které mù¾e pøijímat koneèný automat.

Vedle dodaných podmínek je mo¾né definovat podmínky vlastní. Jednou mo¾ností je 
definovat podmínku $p(x,y)$ jako mno¾inu kompatibilních hodnot $(a,b)$, tedy $p$ platí, 
pokud $x=a$ a $y=b$, pøípadnì jako mno¾inu nekompatibilních hodnot. Tato mno¾ina je zadaná 
jako tabulka hodnot. Vedle zadání tabulkou je mo¾né zadat podmínku jako predikát, 
který musí platit. Podmínka pak je tvoøena objektem typu podìdìného od tøídy BinRelation 
s implementovanou funkcí checkCouple. Tato funkce dostane jako parametry dvojici 
hodnot a vrátí bool hodnotu zda byla podmínka splnìna nebo ne. Vedle binárních 
podmínek je mo¾né specifikovat podmínky podobným stylem na n-ticích.  Pro v¹echny 
takové podmínky (jak binární tak n-ární) lze pak specifikovat po¾adovaný algoritmus 
hranové konzistence. K dispozici je AC3, AC2001, AC3rm, AC3 pro binární podmínky a 
AC32, AC3rm, AC2001 a AC2008 pro n-ární podmínky. Popis jednotlivých algoritmù mù¾ete 
nalézt v [najít citaci pro algoritmy AC].

\subsubsection{Øe¹iè}
Øe¹iè je objekt typu CPSolver, který se na základì modelu popsaného v pøedhoczí 
sekci pokusí najít øe¹ení. Øe¹iè nejprve pøeète promìnné modelu, které pøevede na 
promìnné øe¹ièe (IntegerVariable na IntDomainVar, RealVariable na RealVar a SetVariable 
na SetVar). Poté pøeète podmínky z modelu a vyrobí na jejich základì podmínky øe¹ièe. 
Øe¹iè poté pou¾ije vyhledávací strategii a hledá øe¹ení. Proto¾e je volba správné 
strategie klíèovým faktorem pro rychlost øe¹ení, je mo¾né nastavit její rùzné parametry. 
U¾ivatel si mù¾e zvolit tzv. selektor a iterátor. Selektor vybírá, kterou promìnnou 
vybrat k pøí¹tímu rozhodnutí solveru. Iterátor pak vybírá jednotlivé mo¾né hodnoty a 
iteruje pøes nì. Choco ve standardní distribucí nabízí základní selektory jako promìnnou 
s minimální doménou, promìnnou s maximální doménou apod. Iterátory pak mohou zkou¹et 
hodnoty v sestupném nebo vzestupném poøadí. Alternativou k iterátoru je selektor hodnoty, 
který na po¾ádání vrátí dal¹í mo¾nou hodnotu. Pro selektor hodnoty je mo¾né pou¾ít 
napøíklad minimální hodnotu domény, náhodnou hodnotu domény apod. Pro rùzné skupiny 
promìnných je mo¾né zvolit vlastní strategie tak, aby co nejlépe vystihovaly zadání 
problému. V tomto pøípadì se definuje chování øe¹ièe pomocí tzv. cílù. Cíl obsahuje 
definici strategie tzn. selektor nad danými promìnnými a iterátor nad hodnotami.

Proto¾e pøi øe¹ení rozsáhlých problémù mù¾e dojít k neúmìrnému èasu výpoètu, 
spotøebovaných systémových prostøedkù apod, lze definovat omezení na øe¹iè. Øe¹iè 
je mo¾né omezit èasem, poètem uzlù vyhledávacího stromu, hloubkou backtrackingu, 
poètem neúspì¹ných øe¹ení a nebo CPU èasem. U¾ivatel si mù¾e vedle tìchto limitù 
na øe¹ení nastavit vlastní limity.

Po pøeètení modelu a definici strategií pøichází samotné øe¹ení problému. Øe¹iè 
poskytuje interface jak pro iterování pøes øe¹ení (solve, nextSolution), tak pro 
získání v¹ech øe¹ení naráz. Dále øe¹iè umo¾òuje urèit promìnnou, kterou se pokusí 
minimalizovat/maximalizovat. Øe¹ení je ulo¾eno v promìnných øe¹ièe, ne v promìnných 
modelu, které byly u¾ivatelem definovány. Je tedy nutné promìnné øe¹ièe z øe¹ièe 
získat zavoláním funkce CPSolver::getVar která jako parametr pøijme promìnnou modelu 
a vrátí promìnnou øe¹ièe. 

\subsection{Nástroje pro podporu modelování}
Choco neobsahuje nástroj na grafickou visualisaci vyhledávacího stromu podobnì jako 
má napøíklad systémk Mozart nebo Gecode. Choco umo¾òuje vypsat log z prùbìhu øe¹ení. 
Logu se dají nastavit rùzné úrovnì podrobnosti od zcela tichého a¾ po kompletní výpis 
v¹ech událostí, které choco internì provádí. [Protyp pokud bude odpoved autoru zaporna] 
Mimo zmínìného logování u¾ivatel nemá k dispozici jiné debugovací nástroje jako napøíklad 
interaktivní procházení prohledávacího stromu a nebo zmínìnou visualisaci. [/prototyp]

\subsection{Subjektivní hodnocení solveru}
Solver Choco se ukázal jednoduchý na bì¾né pou¾ití. I èlovìk, které pøedtím 
nemìl zku¹enosti s javou, omezujícími podmínkami ani tímto solverem nemìl problém 
zaèít pou¾ívat solver a prakticky ho uplatnit. Systém je dobøe zdokumentován, i 
kdy¾ v dobì psaní této práce je dokumentace lehce nepøehledná. Pøesto v ní peèlivvý 
ètenáø najde zpravidla v¹e co potøebuje. Programátorská dokumentace je generovaná 
systémem JavaDoc. Díky tomu je ve vìt¹inì bì¾ných Java IDE u¾ivateli k dispozici 
ji¾ bìhem výbìru funkce pomocí intellisense, co¾ napomáhá rychlému pochopení øe¹ièe. 
Vývoj øe¹ièe je provozován na serveru SourceForge, je tedy jednoduchou standardní 
formou pøístup jak ke zdrojovým kódùm aplikace tak k historii skrze verzovací 
nástroj subversion. Na serveru sourceforge je také umístìné fórum technické 
podpory, ve kterém autoøi odpovídají na dotazy u¾ivatelù. Reakèní doba je velmi 
nízká a úroveò odpovìdí na takové úrovni, ¾e vìt¹ina problémù je rychle vyøe¹ena.

\section{Minion}
Minion je øe¹iè omezujících podmínek, který funguje jako samostatná aplikace, která
na vstupu dostane popis problému a na výstupu vrátí øe¹ení. Jako mnoho ostatních 
øe¹ièù je k dispozici na serveru sourceforge.net jako open-source program. Oproti ostatním øe¹ièùm, 
které fungují jako knihovny pro nìjaký programovací jazyk a je mo¾né je pou¾ít jako subsystém
pro øe¹ení omezujících podmínek pøímo uvnitø programu, Minion pracuje samostatnì. 
Popis problému dostává ve speciálním datovém souboru, který je rozdìlen na definici promìnných,
definic podmínek na nich a pøípadnou definici objektivní funkce. Výstup øe¹ièe pak mù¾e 
u¾ivatel pøeèíst na standardním výstupu. Samotný jazyk pro popis problému by se dal
nejlépe popsat jako "assembler pro omezující podmínky". ©kálovat problém není mo¾né 
bez zmìny vstupního souboru, proto¾e ten je navr¾ený jak na míru problému tak jeho
parametrù -- zatímco v jiných øe¹ièích staèí pro zmìnu z problému ètyø královen 
na osm královen jenom pøepsat konstantu 4 na 8, zde je nutné pøepsat vìt¹inu vstupního
souboru. Mno¾ina podporovaných podmínek je koneèná a není mo¾né pøidat novou podmínku
bez zásahu do kódu samotného øe¹ièe. U¾ivatele jistì zaujme, ¾e není mo¾né specifikovat
podmínku $a = \sum{w_i x_i}$, ale je nutné ji nahradit dvojicí $a \leq \sum{w_i x_i}$,
 $a \geq \sum{w_i x_i}$. Podmínky také není mo¾né øetìzit. Pokud je øetìzení podmínek
 pro model podstatné, je nutné zavést auxiliary promìnnou, pøes kterou se podmínka
 svá¾e. Minion podporuje ètyøí typy promìnných -- bool, bound, discrete a sparseboud.
 Bool promìnné jsou promìnné s doménou $\{0,1\}$. Bound promìnné jsou internì ulo¾ené
 pouze okraji intervalu, který reprezentují. Discrete promìnné také reprezentují zadaný interval,
 ale oproti bound promìnným mohou obsahovat v intervalu díru. Koneènì sparsebound 
 reprezentuje doménu, která sestává z pøevá¾nì osamocených hodnot, které jsou definovány
 ve vstupním souboru. V prùbìhu výpoètu se pro sparsebound promìnné upravují opìt pouze
 okraje intervalu. Z tìchto promìnných je pak mo¾né vytváøet vektory, matice a n-tice.
 
Formát vstupu pro minion není moc human-friendly. Ji¾ pro malé problémy roste poèet 
pomocných promìnných nad rozumné meze a vstup se stává nepøehledným. Proto se vyplatí
vstupní soubor generovat automaticky. Buï pomocí ad hoc generátorù, které si u¾ivatel
napí¹e napø. jako souèást svého programu, který posléze volá minion a nebo pomocí nástroje
Tailor popsaného v sekci \ref{tailor}.

\subsection{Popis øe¹ièe omezujících podmínek}
Jak bylo zmínìno v pøedchozí sekci, minion je samostatný spustitelný program, který 
jako parametr dostane název vstupního souboru (pøípadnì dostane vstup na standardním vstupu) 
a na standardní výstup pøípadnì do souboru vypí¹e øe¹ení. Umí pracovat pouze s celými èísly, 
problém tedy musí být zakódován tak, aby se jimi dal vyjádøit. Formát vstupního souboru 
prochází mezi verzemi zmìnami, ale øe¹iè by mìl být schopen pracovat se v¹emi star¹ími 
formáty. Aktuální verze formátu vstupního souboru má èíslo 3. Ka¾dý soubor obsahuje 
na prvním øádku specifikaci formátu, v tomto pøípadì tedy \texttt{MINION 3}. Dále 
následují v libovolném poøadí a s libovolnou mo¾ností opakování jednotlivé sekce souboru. 
Soubor mù¾e obsahovat sekci s definicí promìnných, sekci s definicí n-tic, sekci s 
definicí podmínek a koneènì sekci s definicí parametrù hledání øe¹ení. Podmínky se 
nechovají jako klasické funkce, ale jako predikáty, které musí být splnìny a nemají 
návratovou hodnotu. To vede k tomu, ¾e abychom slo¾ili efekty více podmínek, musíme 
zavést pomocnou promìnnou. Napøíklad mìjme podmínku $|x| < y$ a k dispozici jen podmínky 
 $X = |Y|$ a $X < Y$. Pro podmínku $|x| < y$ pak musíme zavést pomocnou promìnnou 
 $a$ a do modelu pøidat následující dvì podmínky $a = |x|$, $a < y$. Pøehled podporovaných 
 podmínek øe¹ièe Minion lze nalézt v tabulce \ref{podporovane-podminky}. Parametry 
 vyhledávání lze ovlivnit buï pøímo v definièním souboru, napøíklad poøadí promìnných 
 apod. a nebo skrze parametry pøíkazové øádky.
 
\subsection{Nástroje pro podporu modelování}
Minion umo¾òuje vypsat na standardní výstup prohledávací strom, ve kterém je mo¾né 
sledovat èinnost solveru na pøedlo¾eném modelu. Vlastní nástroj pro visualisaci 
øe¹ení systém neobsahuje. Proto¾e je ruèní modelování v systému Minion pomìrnì obtí¾né,
u¾ivatel pravdìpodobnì pou¾ije pro tvorbu modelu nástroj Tailor. Ten umo¾òuje jak
pøeklad programu v Essence' do formátu Minion, tak pøímo spustit minion a sledovat
øe¹ení z Tailoru. 

\subsection{Subjektivní hodnocení solveru}
Autoøi na stránkách solveru uvádí, ¾e je Minion nejrychlej¹í solver, který je k 
dispozici. Toto necháme na posouzení ètenáøi po vlastních pokusech se systémem pøípadnì
po zhodnocení výsledkù na¹ich benchmarkù. Rozhodnì se ukázalo, ¾e v pøípadì kdy systému
nedojde pamì» z dùvodu velikosti problému, je i pro velké instance problému schopen 
okam¾ité odpovìdi. Nejvìt¹í pøeká¾kou je tedy vstupní formát, ale tento problém je 
elegantnì øe¹itelný zmínìným programem Tailor. Jako samostatný program, který je
mo¾né zavolat s definicí problému a on na standardní výstup vrátí øe¹ení je pou¾itelný
jako øe¹iè i pro takové programy jako napøíklad Bash skripty. Jediný po¾adavek na 
pou¾ití je schopnost sestavit vstupní soubor. Co se týèe dokumentace, je k dispozici
referenèní pøíruèka, která obsahuje popis v¹ech podmínek a vstupního formátu souboru.
Teké je souèástí pøíruèky jemný úvod do pøevodu CSP modelu na vstupní soubor Minionu. 

\section{Gecode}
Gecode je C++ knihovna pro øe¹ení problémù s omezujícími podmínkami. Gecode umo¾òuje
modelovat problémy obsahující celoèíselné promìnné, booleovské promìnné a koneèné mno¾iny 
celých èísel. Gecode je podobnì jako vìt¹ina ostatních zde prezentovaných solverù
free open source software. Knihovna je distribuovaná ve formì zdrojových kódù a pro 
systém Windows je navíc pøipravený instalátor s pøedkompilovanými knihovnami. Volitelnì 
u¾ivatel potøebuje knihovnu Qt, která je pou¾ita k vykreslování grafického nástroje
Gist. Gecode nabízí vedle bì¾ných podmínek podmínky pro plánování,
podmínky nad koneènými automaty, podmínky pro grafy a dal¹í. Blí¾e tyto podmínky 
rozebereme v následující sekci. Gecode hojnì vyu¾ívá mo¾nosti v C++ pøetí¾it funkce 
a operátory. Díky tomu má mnoho podmínek stejného typu nad rùznými datovými typy
stejný název. Pøetí¾ení operátorù pak pomáhá zjednodu¹it práci s výrazy. Nevýhodou je, 
¾e u¾ivatel ztrácí explicitní vìdomí, ¾e operátor, který aplikoval na promìnné není 
obyèejný operátor ale jde o èást podmínky. Klíèovou postavou øe¹ièe Gecode je Christian 
Schulte, který se také podílí na vývoji systému Mozart/Oz.

\subsection{Popis øe¹ièe omezujících podmínek}
Problém je modelován jako tøída odvozená od tøídy Space. V této tøídì jsou definovány
promìnné a podmínky. Promìnné jsou objekty typu IntVar pro celoèíselné promìnné, 
BoolVar pro booleovské promìnné a SetVar pro koneèné celoèíselné mno¾iny. Oproti 
ostatním øe¹ièùm nejsou booleovské promìnné pouze celoèíselné promìnné= s doménou ${0,1}$.
Není dokonce ani mo¾né pro booleovskou promìnnou $b$ a celoèíslenou promìnnoi $i$ 
vlo¾it podmínku $b=i$. Pro vztahy mezi booleovskými a celoèíselnými promìnnými se 
pou¾ívá buï reifikace ($(i = 1) \Leftrightarrow b = 1$) a nebo kanálovací podmínky
 $b_i = j \Leftrightarrow i = j$ (napø. $b = (0,0,0,1,0,0)$, $i = 3$). Podmínky jsou 
 globální funkce v namespace Gecode, které je nutné zaregistrovat v modelu pomocí
 funkce \texttt{post}. Díky pøetí¾ení funkcí je vìt¹ina podmínek implementovaná tak,
 ¾e pokud má napøíklad smysl volat danou podmínku jak s dvojicí promìnných tak s promìnnou
 a vektorem promìnných, existují obì varianty a díky pøetí¾ení se vybere ta správná.
V pøípadì ¾e u¾ivatel pou¾ije tzv. {\em minimodel}, tak je umo¾nìno pou¾ívat zkrácených výrazù, 
napøíklad podmínku $a = x \cdot y$ mù¾eme psát \texttt{post(home, a == x*y )} místo \texttt{mult(home,x,y,a)}. 
Minimodel ale funguje pouze jako "syntaktický cukr", proto¾e nepøiná¹í ¾ádné nové
podmínky, pouze zjednodu¹uje zápis stávajících podmínek. 

Vedle standardních aritmetických podmínek a podmínek na uspoøádání nabízí Gecode
¹iroké spektrum specializovaných podmínek. Pro SAT je k dispozici podmínka \texttt{clause(space,rel,x,y,z)},
která odpovídá podmínce $\bigvee {x_i} \vee \bigvee{\neg y_i}$ resp. $\bigwedge {x_i} \wedge \bigwedge{\neg y_i}$
v závislosti na parametru {\em rel}. Zajímavá je podmínka count, která zaji¹»uje, ¾e
bude platit $\#\{i \in \{0, ..., |x|-1\}|x_i = j\} = y_j$. To jinými slovy znamená,
¾e benchmark Magická sekvence se dá namodelovat pomocí jedné podmínky \texttt{count(*this, x, x)}.
K dispozici jsou také extensional podmínky. To jsou podmínky, které jsou definované skrze 
nìjakou extension. Napøíklad deterministický koneèný automat. Podmínka pak má tvar
 {\em $x$ je slovo, které pøijme automat $A$}. Pro grafové podmínky Gecode poskytuje podmínku
 {\em $x$ je hamiltonovská kru¾nice}. Z oblasti plánování je k dispozici podmínka
 \texttt{cumulatives(home, resource, start, duration, end, height, limit, atmost)}, 
která zajistí, ¾e v mno¾inì úkolù T (úkol $T_i = \langle \mathrm{resource}_i, \mathrm{start}_i,
\mathrm{duration}_i, \mathrm{end}_i, \mathrm{height}_i \rangle$) je pou¾ito maximálnì 
(pøípadnì v závislosti na parametru atmost minimálnì) $\mathrm{limit}$ zdrojù ???!!!???
zjistit pøesnou definici co to dìlá, nedává mi to moc smysl ???!!!???. 

Podmínky nad mno¾inami zahrnují standardní mno¾inové operace. Dále podmínku na kardinalitu mno¾iny,
a podmínku zaji¹»ující, ¾e vá¾ený souèet mno¾iny má danou hodnotu, tedy pokud máme mno¾inu
 $x$ a váhový vektor $w$ a souèet má být $y$, tak má podmínka tvar $\sum{x_i w_i} = y$. 
 Dále jsou k dispozici dvì podmínky související s konvexností.
Mno¾ina je konvexní, pokud je tvoøena souvislým intervalem èísel. Mno¾ina $\{1,2,3\}$ 
tedy konvexní je, zatímco mno¾ina $\{1,3,4\}$ konvexní není, proto¾e neobsahuje èíslo 2.
Konvexní obálkou (convex hull pro pøeklad) je pak nejmen¹í konvexní nadmno¾ina.
Podmínka \texttt{home,x} zajistí, ¾e $x$ je konvexní a \texttt{home,x,y} znamená,
¾e $y$ je konvexní obálka pro $x$. 

Pokud je potøeba modelovat optimalizaèní problém, tak se tøída reprezentující problém
podìdí od tøídy MaximizeScript místo od tøídy Space. Objektivní funkci pak u¾ivatel definuje
override metody cost, která vrátí její hodnotu pro aktuální model. Prohledávání je
øízeno funkcí \texttt{branch(home,x,var,val)}, kterou se nastaví prohledávání vektoru
 $x$. Parametrem $var$ se nastavuje algoritmus pro výbìr promìnné pøi distribuci a 
parametrem $val$ se zvolí algoritmus pro výbìr hodnoty promìnné, podle které má být
distribuce provedena. Pro samotné hledání problému je nutné pou¾ít následující kód: 

\begin{verbatim}
Model* m = new Model;	
SEARCH<Model> e(m);
delete m;

while (Model* s = e.next())
{
	s->print();
	delete s;
}  
\end{verbatim}

Model je tøída podìdìná od Space resp. MaximizeScript, která reprezentuje model CSP.
Místo {\em SEARCH} jenutné zadat konkrétní vyhledávací algoritmus. K dispozici je 
\texttt{DFS} -- depth-first left-most search, \texttt{LDS} -- limited discrepancy,
\texttt{BAB} -- branch-and-bound and finally \texttt{Restart} -- depth-first left-most
restart search. Algoritmy \texttt{BAB} a \texttt{Restart} se dají vyu¾ít pro hledání 
optimálního øe¹ení. V¹echny algoritmy podporují paralelní výpoèet. U¾ivatel tedy na
poèítaèi s více procesory mù¾e dosáhnout výraznì rychlej¹ího výpoètu.  

\subsection{Nástroje pro podporu modelování}
Pro zobrazení prohledávacího stromu nabízí Gecode nástroj Gist. Jedná se o nástroj velmi
podobný nástroji Explorer v øe¹ièi Mozart/Oz. Rozhraní, grafické symboly i funkce jsou
s Explorerem toto¾né. Funkce, kterou má Gist navíc je Gist node statistics, která
pro daný uzel prohledávacího stromu doká¾e zobrazit statistiku obsahující informace
o hloubce aktuálního uzlu vùèi koøenu stromu, aktuální vý¹ce podstromu daného uzlu 
a poètu úspì¹ných/neúspì¹ných øe¹ení v podstromu. Gist také obsahuje nástroj Inspector,
který funguje stejnì jako Inspector v Mozart/Oz.

\subsection{Subjektivní hodnocení solveru}
Gecode je typickým pøíkladem kvalitního software, který není rozumnì pøístupný u¾ivateli
kvùli absenci dokumentace. A¾ do verze 3.0.0, která vy¹la v bøeznu 2009 existovala pouze
programátorská dokumentace ve formátu doxygen. Ukázkové modely byly navíc obalené ¹ablonovou
tøídou example pro jejich snadnìj¹í spu¹tìní, ale pro samotné pochopení jak umístit 
øe¹iè do svého programu toto nestaèilo a bylo nutné prozkoumat dùkladnì zdrojové kódy øe¹ièe.
S verzí 3.0.0 vy¹la i elektronická kniha Modelling with Gecode \cite{gecode:modelling},
která toto zcela zmìnila. Jedná se o tutoriál, který krok po kroku provádí od základního 
po¾adavku -- z daného modelu vytvoøit zadání pro øe¹iè a¾ po ¹iroké mo¾nosti dal¹ího
nastavení øe¹ièe. Vedle klasické dokumentace existuje také emailová konference, která
je v dobì psaní této práce výborným místem pro kladení dotazù, na které zpravidla 
autoøi odpovídají ve velmi krátkém èase. 

\section{\eclipse}
\eclipse je open source implementací programovacího jazyka Prolog. \eclipse je dodáván
s knihovnami pro øe¹ení omezujících podmínek. Je mo¾né øe¹it modely nad celými èísly,
reálnými èísly a mno¾inami celých èísel. Øe¹iè zde není dodáván jako jedna knihovna, ale 
jako více specializovaných knihoven. Základem je knihovna {\em ic} -- interval constraints,
která obsahuje základní aritmetické podmínky. Dále je k dispozici knihovna {\em ic\_global}, pro
globální podmínky jako \texttt{alldifferent} (tato podmínka je implementovaná i v {\em ic}, 
ale ve slab¹í podobì). Pro rozvrhovací problémy je pøipravena knihovna {\em ic\_cumulative} a 
pro koneèné mno¾iny nad celými èísly knihovna {\em ic\_sets}.


\section{SICStus Prolog}

\section{Tailor}
\label{tailor}
Tailor není øe¹iè omezujících podmínek. Jedná se o systém na pøeklad kódu v programovacím
jazyce Essence' do vstupního formátu souboru pro systém Minion a nebo do zdrojových 
kódù pro øe¹iè Gecode.
