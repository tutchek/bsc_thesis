\chapter{Constraint solvers}
\thispagestyle{myheadings}\markright{$ $Id$ $}

\section{Mozart/Oz}
Mozart je implementací multiparadigmatického jazyka Oz. Oz je funkcionální jazyk, 
který má vestavìnou podporu pro vícevláknové aplikace, podporu pro paralelizaci a 
mimo jiné obsahuje také vestavìnou podporu pro øe¹ené problémù s omezujícími podmínkami. 
Jak bylo zmínìno døíve, jde o jazyk multiparadigmatický, lze v nìm tedy psát i 
imperativní programy stejnì jako logické programy (podobné prologu). Dále je mo¾né 
definovat tøídy vèetnì dìdiènosti a praocvat s od nich odvozenými objekty. Tento 
jazyk byl navr¾en pro co nejvy¹¹í variabilitu pøi pou¾ití, proto¾e programátor 
mù¾e vyu¾ít naráz kombinaci funkctionálního, logického i imperativního programování, 
OOP a dal¹í najednou. Ve standardní distribuci je dodáván jako samostatný pøekladaè, 
který vytvoøí nativní programy pro daný operacní systém. Mimo toho umí také bì¾et 
v interaktivním módu, kdy se jednotlivé bloky pøíkazù posílají pøímo kompilátoru. 
Jako IDE se pou¾ívá bì¾nì systém EMACS, se kterým je Mozart/Oz dodáván. 

Podobnì jako v jiných funkcionálních jazycích je do promìnné mo¾né pøiøadit pouze 
jednu hodnotu za dobu jejího ¾ivota. Proto má ka¾dá promìnná vedle hodnoty je¹tì 
stav. V pøípadì, ¾e má dojít k akci nad promìnnou do které není nic pøiøazeno, aè 
by to pøíkaz vy¾adoval dojde k pozastavení vlákna dokud nebude do promìnné pøiøazeno. 
To umo¾òuje provést následující program:

\begin{verbatim}
a = 5
if a > b then c = 5 else c = 6
b = 4
// V c nyní bude hodnota 5
\end{verbatim}

Jazyk obsahuje vestavìnou podporu pro paralelní výpoèty, tedy na úrovni jazyka 
je mo¾né vytváøet vlákna a synchronizaèní primitiva. Jazyk navíc podporuje pøedat 
výpoèet na jiný poèítaè skrze protokol TCP/IP. Lze tedy vyu¾ít cluster poèítaèù 
pro zrychlení nároèných výpoètù.

\subsection{Popis øe¹ièe omezujících podmínek}
Pøo øe¹ení problémù s omezujícími podmínkami obsahuje vestavìný øe¹iè problémù s 
koneènou doménou (finite domain). Pro tyto úèely se mno¾inou s koneènou doménou 
rozumí koneèná mno¾ina pøirozených èísel s nulou. Øe¹iè obsahuje omezení na nejvy¹¹í 
mo¾nou hodnotu promìnné. Výpoèetní model pro propagaci podmínek se jmenuje prostor 
(space) a je tvoøen nìkolika propagátory napojenými na constraint store. Constraint 
store obsahuje konjunkci základních podmínek, tedy podmínek ve tvaru $x=n$ nebo $x \in 
D$. Tedy mù¾e vypadat napøíklad $x = 6 \& y \in 1 ... 12 \& z = y$. Propagátory 
obsahují ostatní podmínky, tedy napøíklad $x>y$ nebo $a^2 + b^2 = c^2$. Propagátor 
pro podmínku $c$ je samostatný výpoèetní agent, který se sna¾í omezit domény promìnných, 
které jsou obsa¾ené v $c$. Øe¹ením je pak takové pøiøazení hodnot promìnným, které 
splní v¹echny podmínky dané propagátory.

\begin{example} Mìjme promìnné $X$ a $Y$ a následující podmínky: $X \in \{0..9\}$, $Y \in \{0..9\}$, $X+Y = 9$, $2X + 4Y = 24$. 
\begin{enumerate}
  \item Constraint store obsahuje: $X \in \{0..9\}$, $Y \in \{0..9\}$. Propagátory: $X+Y = 9$ a $2X + 4Y = 24$.
  \item	První propagátor nemù¾e udìlat nic, druhý ale mù¾e zmìnit constraint store tak, ¾e obsahuje  $X \in \{0..8\}, Y \in \{2..6\}$.
  \item	První propagátor nyní mù¾e zmìnit constraint store na $X \in \{3..7\}$, $Y \in \{2..6\}$.
  \item	Druhý propagátor nyní zmìní constraint strore na $X \in \{4..6\}$, $Y \in 3..4$.
  \item	První propagátor zmìní constraint store na $X \in \{5..6\}$, $Y \in \{3..4\}$
  \item	Druhý propagátor nakonec zmìní constraint store, tak ¾e obsahuje $X = 6$, $Y = 3$.
\end{enumerate}
\end{example}

Propagace mù¾e být buï intervalová nebo doménová. Zatímco intervalová propagace 
pouze mìní okraje domény, doménová také odstraòuje vnitøní hodnoty domény. Pøesto¾e 
doménová propagace vypadá jako lep¹í techhnika, pou¾ívá se spí¹e intervalová pro její 
výpoèetní jednoduchost.

Ji¾ pro jednoduché problémy ale propagace nemusí vést k výsledku. Vezmìme napøíklad 
problém: $x \neq y$, $x \neq z$, $y \neq z$, $x \in \{0..1\}$, $y \in \{0..1\}$, $z \in \{0..1\}$. 
Tento problém nelze více propagovat, v¹echny podmínky lze splnit ale ¾ádná promìnné 
není pøiøazena hodnota. V této chvíli lze pou¾ít distribuci. Problém $P$ je distribuován 
pomocí podmínky $C$, pokud vyøe¹íme nové problémy $P \cup \{\neg C\}$ a $P\{C\}$. 
Alespoò v jednom z nových problémù se buï nachází øe¹ení problému $P$ a nebo je 
problém neøe¹itelný. V na¹í reprezentaci se tohoto faktu dá vyu¾ít pro space. 
Pokud se systém dostane do stabilního stavu, kdy ¾ádná podmínka není nesplnìna a 
pøitom není mo¾né pøiøadit ¾ádné promìnné hodnotu, tak vybereme promìnnou $x$ a 
hodnotu $n$ takovou, ¾e je konzistentní se v¹emi podmínkami nad $x$. Tím získáme 
dva nové space, jeden $S \cup {x = n}$ a jeden $S \cup {x \neq n}$. Na obou space 
pak pustíme propagaci. Pokud se dostane opìt do stabilního stavu, znova distribuujeme 
a takto postupujeme a¾ do vyøe¹ení problému a nebo konstatování, ¾e je problém 
neøe¹itelný. Tato metoda je úplná, tedy pokud existuje alespoò jedno øe¹ení, 
pak budou nalezena v¹echna.

Je mo¾né volit z rùzných distribuèních strategií. Volba správné strategie mù¾e 
výraznì ovlivnit dobu výpoètu. Pro vìt¹inu problémù je dobré zvolit first-fail 
strategii, tedy volit promìnnou s nejmen¹í mo¾nou doménou. Pokud ale ¾ádná dodávaná 
distribuèní strategie nevyhovuje, je mo¾né implementovat své distribuèní strategie, 
plnì na míru problému.

Pro hledání øe¹ení optimalizaèních problémù se dají vyu¾ít dvì techniky. Naivní 
technika spoèívá v postupném zvy¹ování výsledku objektivní  funkce a následném hledání 
øe¹ení, které tomuto výsledku bude odpovídat. Pro tento postup existuje v jazyce 
konstrukce, která pøed splòováním ostatních podmínek postupnì zvy¹uje danou promìnnou. 
Tento postup v¹ak postrádá obecnost a Mozart nabízí lep¹í postup -- techniku branch and bound. 
Tato technika vy¾aduje, aby u¾ivatel sestavil porovnávací funkci. Porovnávací funkce 
jako argumenty pøijímá pøedchozí a aktuální øe¹ení problému. Funkce pak zpravidla 
zavolá objektivní funkci a porovná její výsledky. Tato technika oproti naivní výraznì 
zrychlí výpoèet. 

\subsection{Nástroje pro podporu modelování}
Mozart nabízí u¾ivateli interaktivní nástroj Explorer, který umo¾òuje prozkoumat 
strom øe¹ení vèetnì dílèích rozhodnutí, které øe¹iè bìhem výpoètu uèinil. Explorer 
je mo¾né pou¾ívat také v interaktivním módu a ruènì urèovat, které vìtve øe¹ení prozkoumat. 
 
Koleèka oznaèují uzly rozhodovacího stromu, ve kterých probìhlo rozhodnutí, kosoètverce 
oznaèují nalezení úspì¹ného øe¹ení a ètverec vìtev kde není øe¹ení. Svìtlej¹í barvou 
jsou uvedené uzly, které je mo¾né je¹tì dále expandovat. Na uvedeném obrázku tedy 
máme jedno øe¹ení, dvì neúspì¹ná øe¹ení a pìt okam¾ikù, kdy do¹lo k rozhodnutí z 
nich¾ lze je¹tì ve tøech hledat dal¹í øe¹ení. Explorer umo¾òuje také export 
nakresleného stromu ve formátu PostScript.

\subsection{Implementace benchmarkù}
Ka¾dý implemetovaný benchmark je samostatný solver. Po zavolání pøíslu¹ného 
solveru je vrácena funkce, která je posléze pøedána funkci realizující hledání 
øe¹ení. Jde buï o funkce SearchOne resp. SearchAll, které naleznou jedno nebo 
v¹echna øe¹ení problému a vrátí je v seznamu. Pro spu¹tìní exploreru a interaktivní 
hledání øe¹ení lze pak zavolat ExploreOne resp. ExploreAll.

\subsubsection{Magická sekvence}
\lstloadlanguages{C++}
\definecolor{bgcolor}{rgb}{1,1,0.6} % definice barvy
\lstset{         % nastaveni prostredi listings
  language=C++,
	basicstyle=\tiny,
  keywordstyle=\bfseries,
  identifierstyle=\itshape,
  stringstyle=\ttfamily,
  numbers=none,
  numberstyle=\tiny,
  numbersep=5pt,
  frameround=ffff,
  extendedchars=true,
  tab=~,
  tabsize=2,
  frame=single,
  captionpos=b,
  showspaces=false,
  showstringspaces=false,
  breaklines=true
}
\begin{figure}[ht]
\caption{Implementation of Magic Sequence Problem in Essence}
\begin{lstlisting}
fun {MagicSequence Size}
   proc {$ Sol}
      {FD.tuple magic Size 0#(Size-1) Sol}

      {For 1 Size 1
       proc {$ I}
	  Vector
       in
	  {FD.tuple v Size 0#1 Vector}
	  {For 1 Size 1
	   proc {$ J}
	      Vector.J = Sol.J =: I-1
	   end}
	  
	  {FD.reified.card Sol.I V Sol.I 1}
       end}

      {FD.distribute ff Sol}
   end
end
\end{lstlisting} 
\end{figure}
%$

\section{Choco}
Choco je øe¹iè omezujících podmínek implementovaný jako knihovna pro programovací 
jazyk Java. Choco je distribuováno jako balíèek JAR s dokumentací ve formátu Javadoc. 
Instalace je tedy velmi snadná i pro zaèínajícího programátora v Javì a v bì¾nì 
pou¾ívaných IDE nezabere více ne¾ pìt minut. Díky programovacímu jazyku Java je 
solver Choco dostupný na mnoha platformách a operaèních systémech. Proto¾e ale 
není cílem této práce popisovat vlastnosti hostitelského programovacího jazyka, 
nebudeme zde dále rozebírat mo¾nosti Javy. Choco je vyvíjeno na Ecole des Mines 
de Nantes ve Francii a je volnì dostupné na serveru Sourceforge. Aktuální hlavní 
verze má èíslo 2. Choco dìlí øe¹eí problému na dvì èásti -- model a samotý øe¹iè. 
Model obsahuje promìnné a podmínky dané zadáním. Øe¹iè pak dostane na vstupu model 
a pokusí se v nìm najít øe¹ení. Model mù¾e obsahovat jako promìnné celá èísla, 
reálná èísla a mno¾iny. Øe¹iè je pak schopný k danému modelu najít øe¹ení. U¾ivatel 
mù¾e od øe¹ièe získat informaci, zda je problém øe¹itelný èi zda neobsahuje spor. 
Pro samotná øe¹ení poskytuje interface umo¾òující dotázat se na úrvní, následující 
a nebo na v¹echna øe¹ení. Pokud mu urèíme promìnnou s hodnotou objektivní funkce 
umo¾òuje øe¹iè tuto promìnnou minimalizovat nebo maximalizovat. Øe¹iè dále podporuje 
volbu strategií na míru øe¹enému problému. Promìnné modelu a øe¹ièe jsou ve vzájemném 
vztahu. Pøesto není mo¾é získat øe¹ení pøímo z promìnných modelu ale je nutné je 
získat pøes odpovídající promìnné øe¹ièe.

\subsection{Popis øe¹ièe omezujících podmínek}
Jak bylo naznaèeno v pøedchozí sekci, je øe¹ení problému rozdìleno na dva 
úkoly -- nadefinovat model a pøedlo¾it ho správnì nastavenému øe¹ièi. Jak model 
tak øe¹iè jsou tøídy, které si u¾ivatel instancuje do pøíslu¹ného objektu. 
Popí¹eme nejprve model a poté øe¹iè.

\subsubsection{Model}
Model  je tvoøen objektem tøídy CPModel. Promìnné modelu jsou v Choco reprezentovány 
objekty následujících typù IntegerVariable, RealVariable a SetVariable. Tyto promìnné 
se standardnì nevytváøení pomocí klíèového slova new, ale choco má pro tento úèel 
pøipravené tovární metody. Takovéto promìnné je nutné v modelu zaregistrovat pomocí 
funkce CPModel::addVariable resp. CPModel.addVariables (pro zaregistrování celého 
pole promìnných). Pøi registraci promìnné do modelu je mo¾né urèit dodateèné vlastnosti 
promìnných, napøíklad zda jde o decision promìnné, nebo o promìnnou obsahující výsledek 
objektivní funkce. Tyto vlastnosti není nutné v¾dy zadávat, ale mohou výraznì urychlit 
výpoèet. Alternativou je definovat si tyto vlastnosti v øe¹ièi. Toto bude popsáno v 
následující sekci.

Po zaregistrování promìnných následuje definice omezujících podmínek. Je mo¾né pou¾ít 
jak ¹irokou nabídku podmínek dodaných s øe¹ièem, tak si definovat vlastní podmínky. 
Podmínky dodané s øe¹ièem jsou vypsané v tabulce (tabulka). Lze je rozdìlit na základní 
podmínky (pravda, nepravda, operátory uspoøádání), a základní výrazy (goniometrické 
funkce, mocniny, sumy), ostatní podmínky (\texttt{abs}, \texttt{div}, \texttt{max}, ...), reifikované podmínky 
(\texttt{and}, \texttt{or}, \texttt{ifOnlyIf}) a globální podmínky (\texttt{allDifferent}, \texttt{occurenceMax}, ...). K dispozici 
jsou také podmínky pro modelování geometricých podmínek, podmínky pro rozvrhování a 
podmínky pro sekkvenci promìnných, které mù¾e pøijímat koneèný automat.

Vedle dodaných podmínek je mo¾né definovat podmínky vlastní. Jednou mo¾ností je 
definovat podmínku $p(x,y)$ jako mno¾inu kompatibilních hodnot $(a,b)$, tedy $p$ platí, 
pokud $x=a$ a $y=b$, pøípadnì jako mno¾inu nekompatibilních hodnot. Tato mno¾ina je zadaná 
jako tabulka hodnot. Vedle zadání tabulkou je mo¾né zadat podmínku jako predikát, 
který musí platit. Podmínka pak je tvoøena objektem typu podìdìného od tøídy BinRelation 
s implementovanou funkcí checkCouple. Tato funkce dostane jako parametry dvojici 
hodnot a vrátí bool hodnotu zda byla podmínka splnìna nebo ne. Vedle binárních 
podmínek je mo¾né specifikovat podmínky podobným stylem na n-ticích.  Pro v¹echny 
takové podmínky (jak binární tak n-ární) lze pak specifikovat po¾adovaný algoritmus 
hranové konzistence. K dispozici je AC3, AC2001, AC3rm, AC3 pro binární podmínky a 
AC32, AC3rm, AC2001 a AC2008 pro n-ární podmínky. Popis jednotlivých algoritmù mù¾ete 
nalézt v [najít citaci pro algoritmy AC].

\subsubsection{Øe¹iè}
Øe¹iè je objekt typu CPSolver, který se na základì modelu popsaného v pøedhoczí 
sekci pokusí najít øe¹ení. Øe¹iè nejprve pøeète promìnné modelu, které pøevede na 
promìnné øe¹ièe (IntegerVariable na IntDomainVar, RealVariable na RealVar a SetVariable 
na SetVar). Poté pøeète podmínky z modelu a vyrobí na jejich základì podmínky øe¹ièe. 
Øe¹iè poté pou¾ije vyhledávací strategii a hledá øe¹ení. Proto¾e je volba správné 
strategie klíèovým faktorem pro rychlost øe¹ení, je mo¾né nastavit její rùzné parametry. 
U¾ivatel si mù¾e zvolit tzv. selektor a iterátor. Selektor vybírá, kterou promìnnou 
vybrat k pøí¹tímu rozhodnutí solveru. Iterátor pak vybírá jednotlivé mo¾né hodnoty a 
iteruje pøes nì. Choco ve standardní distribucí nabízí základní selektory jako promìnnou 
s minimální doménou, promìnnou s maximální doménou apod. Iterátory pak mohou zkou¹et 
hodnoty v sestupném nebo vzestupném poøadí. Alternativou k iterátoru je selektor hodnoty, 
který na po¾ádání vrátí dal¹í mo¾nou hodnotu. Pro selektor hodnoty je mo¾né pou¾ít 
napøíklad minimální hodnotu domény, náhodnou hodnotu domény apod. Pro rùzné skupiny 
promìnných je mo¾né zvolit vlastní strategie tak, aby co nejlépe vystihovaly zadání 
problému. V tomto pøípadì se definuje chování øe¹ièe pomocí tzv. cílù. Cíl obsahuje 
definici strategie tzn. selektor nad danými promìnnými a iterátor nad hodnotami.

Proto¾e pøi øe¹ení rozsáhlých problémù mù¾e dojít k neúmìrnému èasu výpoètu, 
spotøebovaných systémových prostøedkù apod, lze definovat omezení na øe¹iè. Øe¹iè 
je mo¾né omezit èasem, poètem uzlù vyhledávacího stromu, hloubkou backtrackingu, 
poètem neúspì¹ných øe¹ení a nebo CPU èasem. U¾ivatel si mù¾e vedle tìchto limitù 
na øe¹ení nastavit vlastní limity.

Po pøeètení modelu a definici strategií pøichází samotné øe¹ení problému. Øe¹iè 
poskytuje interface jak pro iterování pøes øe¹ení (solve, nextSolution), tak pro 
získání v¹ech øe¹ení naráz. Dále øe¹iè umo¾òuje urèit promìnnou, kterou se pokusí 
minimalizovat/maximalizovat. Øe¹ení je ulo¾eno v promìnných øe¹ièe, ne v promìnných 
modelu, které byly u¾ivatelem definovány. Je tedy nutné promìnné øe¹ièe z øe¹ièe 
získat zavoláním funkce CPSolver::getVar která jako parametr pøijme promìnnou modelu 
a vrátí promìnnou øe¹ièe. 

\subsection{Nástroje pro podporu modelování}
Choco neobsahuje nástroj na grafickou visualisaci vyhledávacího stromu podobnì jako 
má napøíklad systémk Mozart nebo Gecode. Choco umo¾òuje vypsat log z prùbìhu øe¹ení. 
Logu se dají nastavit rùzné úrovnì podrobnosti od zcela tichého a¾ po kompletní výpis 
v¹ech událostí, které choco internì provádí. [Protyp pokud bude odpoved autoru zaporna] 
Mimo zmínìného logování u¾ivatel nemá k dispozici jiné debugovací nástroje jako napøíklad 
interaktivní procházení prohledávacího stromu a nebo zmínìnou visualisaci. [/prototyp]

\subsection{Subjektivní hodnocení solveru}
Solver Choco se ukázal jednoduchý na bì¾né pou¾ití. I èlovìk, které pøedtím nemìl zku¹enosti s javou, omezujícími podmínkami ani tímto solverem nemìl problém zaèít pou¾ívat solver a prakticky ho uplatnit. Systém je dobøe zdokumentován, i kdy¾ v dobì psaní této práce je dokumentace lehce nepøehledná. Pøesto v ní peèlivvý ètenáø najde zpravidla v¹e co potøebuje. Programátorská dokumentace je generovaná systémem JavaDoc. Díky tomu je ve vìt¹inì bì¾ných Java IDE u¾ivateli k dispozici ji¾ bìhem výbìru funkce pomocí intellisense, co¾ napomáhá rychlému pochopení øe¹ièe. Vývoj øe¹ièe je provozován na serveru SourceForge, je tedy jednoduchou standardní formou pøístup jak ke zdrojovým kódùm aplikace tak k historii skrze verzovací nástroj subversion. Na serveru sourceforge je také umístìné fórum technické podpory, ve kterém autoøi odpovídají na dotazy u¾ivatelù. Reakèní doba je velmi nízká a úroveò odpovìdí na takové úrovni, ¾e vìt¹ina problémù je rychle vyøe¹ena.

\section{Minion}
Minion je øe¹iè omezujících podmínek, který funguje jako samostatná aplikace, která
na vstupu dostane popis problému a na výstupu vrátí øe¹ení. Oproti ostatním øe¹ièùm, 
které fungují jako knihovny pro nìjaký programovací jazyk a je mo¾né je pou¾ít jako subsystém
pro øe¹ení omezujících podmínek pøímo uvnitø programu, Minion pracuje samostatnì. 
Popis problému dostává ve speciálním datovém souboru, který je rozdìlen na definici promìnných,
definic podmínek na nich a pøípadnou definici objektivní funkce.  