\chapter{Conclusions}

This thesis presented a survey of available constraint solvers and more detailed 
described six of them. After reading of this thesis the reader should have a 
basic idea about capabilities and performance of each of them. The solver capabilities 
were measured on the benchmark problems which were implemented in all of them.
On these benchmarks we showed a different approach of each solver to represent
the constraint problem model. 

The reader is encouraged to try the solver which interested him affter reading of this thesis. 
After the solver is choosed the following information in this thesis can be helpful. 
The description of the selected solver is in the chapter \ref{constraint-solvers}.
Examples of the source codes of implemented models are in the appendix \ref{implementation}.
The reader can use them to get an idea about the solver usage. Also it can 
be helpful in the first steps with the chosen solver. The full sources of the benchmarks
are due to the limited capacity placed on the included CD. The list of available constraints
for the selected solver in in the appendix \ref{constraints}. Finally the performance results
 on the given benchmarks is in the chapter \ref{results}.
 
\section{Which solver to choose?}
It is a hard question and there is no easy answer to it. Each solver has an area where
is the best choice of others. If we are forced to use a particular language the best choice
would be the solver in that langauge. That means that for C++ projects we choose Gecode,
for Java projects we use Choco, for Oz projects the Mozart/Oz and finally for Prolog
project we can choose the \eclipse or SICStus Prolog. Since all solvers except SICStus Prolog are free
we can choose any of them if the main criterion is the budget. If we need to model 
exotic constraints we cannot use the Minion system.On the other hand the Minion system
is suitable as an extern solver for environments where is easy to generate an input
file, run a process and then process its output. Example of such environment could
be the bash script language. Last but not least criterion can be the readers conservatism and 
will to learn new things. For example the Mozart/Oz is an interesting solver and language
but if the reader do not want to get familiar with the functional programming paradign that solver would
not be suitable for him.

\section{Future work}
  