\chapter{Benchmarky}

V této kapitole si definujeme benchmarky, které budou dále pou¾ity k otestování 
vlastností jednotlivých øe¹ièù. Jedná se o pìt rùzných problémù, které jsou dobøe 
známy a zdokumentovány. My si na tìchto benchmarcích uká¾eme jak rùzný pøístup 
øe¹ièù k modelování problému tak budeme mìøit kolik spotøebují strojového èasu a 
prostøedkù na vyøe¹ení tìchto problémù. A¾ na sebereferenèní kvíz jsou v¹echny 
benchmarky ¹kálovatelné a dají se pou¾ít také pro testy robustnosti øe¹ièe. My 
budeme tuto robustnost testovat na magické sekvenci. Budeme mìøit, jak velkou 
magickou sekvenci je je¹tì systém schopen spoèítat do daného èasového limitu. 
Poslední benchmark -- umístìní skladù -- je pøíklad optimalizaèní úlohy. 
Øe¹iè bude muset najít optimální øe¹ení na základì dané objektivní funkce. Ke 
ka¾dému benchmarku uvedeme jeho struèný popis, model problému s omezujícími 
podmínkami a ukázkovou implementaci. Pro ukázkovou implementaci pou¾ijeme 
programovací jazyk Essence. Základy tohoto jazyka popí¹eme v první èásti této kapitoly. 

\section{Essence}
Essence je programovací jazyk pro modelování kombinatorických problémù. Umí popsat 
problém v omezujících podmínkách dostateènì srozumitelnì a pøehlednì, aby i èlovìk, 
který tento jazyk nikdy nevidìl, byl schopen urèit, co daný program dìlá. Program 
v Essence sestává ze tøí èástí. První èást definuje verzi jazyka, druhá èást pou¾ité promìnné a 
koneènì tøetí omezující podmínky na tìchto promìnných. Pou¾ité promìnné mohou být 
typu Integer, Boolean a vektor/matice. Jazyk podporuje sum and loop over variable with
given domain. Program mù¾e být rozdìlen na èást, která definuje model a parametry
reprezentující konkrétní zadání. V ukázkách v této kapitole je uvedená pouze definice
modelu. Soubory s definicí parametrù mù¾ete najít na pøilo¾eném CD. Pro pøeklad z 
jazyka Essence do zadání pro solvery slou¾í nástroj Tailor. Ten umí v aktuální verzi 
vytvoøit z Essence zdrojový soubor pro øe¹iè Minion, èást zdrojového kódu pro øe¹iè 
Gecode a zdrojový soubor pro øe¹iè Gecode/FlatZinc. Více o nástroji Tailor je napsáno
v sekci \ref{tailor}.

\section{N-královen}
Tento benchmark vychází z klasické ¹achistické úlohy, rozmístit na ¹achovnici 8 
královen tak, aby se navzájem neohro¾ovaly. My si tuto úlohu zobecníme pro ¹achovnici 
o libovolném poètu sloupcù. Cílem tedy je do tabulky o rozmìrech $n \times n$ rozmístit n 
královen tak, aby se neohro¾ovaly. To znamená, ¾e pro libovolné dvì královny platí, 
¾e nejsou ve stejném sloupci ani øádku a dokonce ani na stejné diagonále.

Pokud tento problém modelujeme, brzy zjistíme, ¾e je výhodné ho modelovat pomocí 
pole promìnných délky n, kde ka¾dá promìnná nabývá hodnot od jedné do n. Dle 
zadání toti¾ nesmí být v jednom sloupci dvì královny a zároveò musí být v ka¾dém 
sloupci alespoò jedna královna. Staèí tedy pro ka¾dý sloupec urèit, v jakém jeho 
øádku bude umístìná královna. Zároveò musí platit, ¾e v¹echny hodnoty musí být 
rùzné, proto¾e nelze umístit dvì královny na jeden øádek. Nakonec musíme vyøe¹it 
podmínku diagonál. Dvì královny jsou na stejné diagonále, pokud je mezi nimi stejný 
poèet sloupcù i øádkù. V na¹em modelu to tedy znamená, ¾e nesmí platit vztah: 
 $\left|Q(i) - Q(j)\right| = \left|i - j\right|$

\subsection{Model CSP}
\begin{itemize}
	\item Promìnné a domény: $q_1, ..., q_n \in \left\{1, ..., n \right\}$, $q_i$ odpovídá øádku ve kterém je umístìná královna ve sloupci $i$
	\item Podmínky:
    \begin{itemize}
     \item ®ádné dvì královny nejsou na stejném øádku: $\forall i,j \in \left\{1, ..., n\right\}: q_i \neq q_j$
	   \item ®ádné dvì královny nejsou na stejné diagonále: $\forall i,j \in \left\{1, ..., n\right\}: |q_i - q_j| \neq |i - j|$
	   \item Pro omezení symetrie: $q_1 < q_n$
	  \end{itemize}
\end{itemize}
The Essence implementation is in figure \ref{benchmark-essence:nqueens}.

\begin{figure}
\caption{\label{benchmark-essence:nqueens}Implementation of N-Queens Problem in Essence}
\begin{lstlisting}
language ESSENCE' 1.b.a
find queens: matrix indexed by [int(1..n)] of int(1..n)
such that
forall i: int(1..n). forall j: int(i+1..n).
alldiff(queens),  
| queens[i] - queens[j] | != | i - j |
\end{lstlisting} 
\end{figure}

\begin{figure}[ht]
\caption{\label{4queens-solution}Solutions of 4-queens problem}
\begin{center}
\begin{tabular}{cc}
\def\mylist{Qa3,Qb1,Qc4,Qd2}
\setchessboard{setpieces=\mylist,showmover=false,
		pgfstyle=straightmove,
		markmove=c4-a4, %Qc4
		markmove=c4-a2,
		markmove=c4-c1,
		markmove=c4-d3,
		markmove=c4-d4}
\def\mylist{Qa3,Qb1,Qc4,Qd2}
\chessboard[maxfield=d4] & \def\mylist{Qa2,Qb4,Qc1,Qd3}
\setchessboard{setpieces=\mylist,showmover=false}
\def\mylist{Qa2,Qb4,Qc1,Qd3}
\chessboard[maxfield=d4]
\end{tabular}
\end{center}
\end{figure}

\section{Magická sekvence}
Magická sekvence je posloupnost èísel, pro kterou platí, ¾e èíslo na pozici $k$ 
(èíslujeme od nuly) urèuje poèet výskytù èísla $k$ v posloupnosti. Napøíklad 
posloupnost $(2\, 1\, 2\, 0\, 0)$ je magickou sekvencí délky pìt, proto¾e platí vý¹e uvedená 
podmínka -- èíslo nula je v posloupnosti právì dvakrát a proto je na první pozici 
dvojka, jednièka je právì jedna a proto má posloupnost na pozici jedna právì èíslo 
jedna a tak dále.

\subsection{Model CSP}
Model pro magickou sekvenci délky $k$:

\begin{itemize}
	\item Promìnné a domény: Prvky magické sekvence: $m_0, ..., m_{k-1} \in 
        \left\{0, ..., k\right\}$.
	\item Podmínky:
	 \begin{itemize}
      \item Prvek na pozici $i$ odpovídá poètu výskytù $i$ v posloupnosti: $\forall i \in 
      {0,...,k-1}: m_i = \sum_{m_j = 1}{1}$.
    \end{itemize}
\end{itemize}
  
V pøípadì, ¾e nelze v øe¹ièi pou¾ít podmínku $m_i = \sum_{m_j = 1}{1}$, dá se sestavit 
alternativní model

\begin{itemize}
	\item Promìnné a domény:
  \begin{itemize} 
	 \item Prvky magické sekvence: $m_0, ..., m_{k-1} \in \left\{0, ..., k\right\}$,
	 \item pomocné promìnné: $\forall i,j \in {0, ..., k-1}: \mathrm{aux}_{ij}$.
	\end{itemize}
	\item Podmínky:
	 \begin{itemize}
    \item $\mathrm{aux}_ij$ má hodnotu 1 pokud $m_j$ má hodnotu i, jinak má 
          $\mathrm{aux}_{ij}$ hodnotu 0: $\forall i,j \in \left\{0, ..., k-1\right\}: 
          (\mathrm{aux}_{ij} = 1) \Leftrightarrow (m_j = i)$,
	  \item Prvky magické sekvence odpovídají souètu pøíslu¹ných pomocných promìnných: 
          $\forall i \in \left\{0, ..., k-1\right\}: m_i = \sum_{j=0}^{k-1}{\mathrm{aux}_{ij}}$.
    \end{itemize}
\end{itemize}
The Essence implementation is in figure \ref{benchmark-essence:mseq}.

\begin{figure}
\caption{\label{benchmark-essence:mseq}Implementation of Magic Sequence Problem in Essence}
\begin{lstlisting}
language ESSENCE' 1.b.a
find s : matrix indexed by [int(0..n-1)] of int(0..n)
such that
  forall i : int(0..n-1).
        ( s[i] = (sum j : int(0..n-1). (s[j] = i)))
\end{lstlisting} 
\end{figure}

\section{Sebereferenèní kvíz}

Sebereferenèní kvíz je kvíz, kde odpovìdi na otázky závisí na odpovìdích na 
ostatní otázky v takovémto kvízu. Typickými otázkami v takovémto testu jsou napøíklad: 

\begin{enumerate}
  \item První otázkou na kterou je odpovìï A je: A: 1, B: 2, C: 3, D: 4, E: na ¾ádnou otázku není odpovìï A
  \item Odpovìdí na tuto otázku je: A: A, B: B, C: C, D: D, E: E
\end{enumerate}
 
Pøi øe¹ení takovýchto kvízù se pou¾ijí zejména reifikované podmínky, tedy podmínky ve tvaru 
 $(C \Leftrightarrow x) \& x \in \left\{0,1\right\}$. Konstrukce takovýchto kvízù je 
 popsaná v èlánku \cite{jios:bubalo}. Zadání testu je následující:

\begin{enumerate}
	\item The first question whose answer is A is:\\
		(A) 4 (B) 3 (C) 2 (D) 1 (E) none of above
	\item The only two consecutive questions with identical answers are: \\
		(A) 3 and 4 (B) 4 and 5 (C) 5 and 6 (D) 6 and 7 (E) 7 and 8
	\item The next question with answer A is: \\
		(A) 4 (B) 5 (C) 6 (D) 7 (E) 8
	\item The first even numbered question with answer B is: \\
		(A) 2 (B) 4 (C) 6 (D) 8 (E) 10 
	\item The only odd numbered question with answer C is: \\
		(A) 1 (B) 3 (C) 5 (D) 7 (E) 9
	\item A question with answer D: \\
		(A) comes before this one, but not after this one (B) comes after this one, but not before this one (C) comes before and after this one (D) does not occur at all (E) none of the above
	\item The last question whose answer is E is: \\
		(A) 5 (B) 6 (C) 7 (D) 8 (E) 9
	\item The number of questions whose answers are consonants is: \\
		(A) 7 (B) 6 (C) 5 (D) 4 (E) 3
	\item The number of questions whose answers are vowels is: \\
		(A) 0 (B) 1 (C) 2 (D) 3 (E) 4
	\item The answer to this question is: \\
		(A) A (B) B (C) C (D) D (E) E
\end{enumerate}

Kvíz mù¾eme modelovat jako tabulku s pìti sloupci (A,B,C,D,E) a deseti øádky 
booleovských promìnných, pro ka¾dou odpovìï v ka¾dé otázce jednu. Hodnota v øádku 
 $i$ a sloupci $j$ je 1, pokud je odpovìï na otázku $i$ rovna $j$. Proto¾e pro 
 ka¾dou otázku platí, ¾e je na ní pouze jedna pøípustná odpovìï, pøidáme do modelu 
 podmínku "v ka¾dém øádku je právì jedna hodnota 1". Tento test má právì jedno øe¹ení:
 
\begin{table}[ht]
\caption{\label{srq-solution-table}Solution of Self Referential Quiz}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|}
\hline Question & A & B & C & D & E \\
\hline\hline 1 & 0 & 0 & 1 & 0 & 0 \\
\hline 2 & 1 & 0 & 0 & 0 & 0 \\
\hline 3 & 0 & 1 & 0 & 0 & 0 \\
\hline 4 & 0 & 1 & 0 & 0 & 0 \\
\hline 5 & 1 & 0 & 0 & 0 & 0 \\
\hline 6 & 0 & 1 & 0 & 0 & 0 \\
\hline 7 & 0 & 0 & 0 & 0 & 1 \\
\hline 8 & 0 & 1 & 0 & 0 & 0 \\
\hline 9 & 0 & 0 & 0 & 0 & 1 \\
\hline 10 & 0 & 0 & 0 & 1 & 0 \\
\hline 
\end{tabular}
\end{center}
\end{table}

\subsection{Model CSP}
	\begin{itemize}
  \item Promìnné a domény: $s_{1|1}, s_{1|2}, ..., s_{10|4}, s_{10|5} \in {0, 1}$.
	\item Podmínky:
	 \begin{itemize}
    \item V ka¾dém øádku je právì jedna hodnota rovna 1: \\
      $\forall i \in \{1, \ldots, 10\}: \left(\sum_{j \in \{1, ..., 5\}}{s_{i|j}}\right) = 1$,
    \item otázka 1, A a¾ D: \\
      $\forall i \in \{1,...,4\}: (s_{1|i} = 1) \Leftrightarrow (s_{4-i+1|1} = 1 \mand (\forall j \in \{1,...,4-1\}: s_{j|1} = 0))$,
    \item otázka 1, E: \\
      $(s_{1|5} = 1) \Leftrightarrow (\forall j \in \{1,...,4\}: s_{j|1} = 0)$,
    \item otázka 2: \\
      $\forall i \in \{1,...,5\}: (s_{2|i} = 1) \Leftrightarrow (\forall j \in \{1,...,5\}: s_{(3+i-1)|j} = s_{3+i|j})$,
    \item otázka 3: \\
      $\forall i \in \{1,...,5\}: (s_{3|i} = 1) \Leftrightarrow (s_{4+i-1|1} = 1 \mand (\forall j \in \{4..2+i\}: s_{j|1} = 0 ) )$,
    \item otázka 4: \\
      $\forall i \in \{1,...,5\}: (s_{4|i} = 1) \Leftrightarrow (s_{2i|2} = 1 /\ ( \forall j \in \{1..i-1\}: s_{2j|2} = 0 )$,
    \item otázka 5: \\
      $\forall i \in \{1,...,5\}: (s_{5|i} = 1) \Leftrightarrow (s_{2i-1|3}=1)$
    \item otázka 6, A: \\
      $\forall i \in \{1,...,5\}: (s_{6|1} = 1) \Leftrightarrow (\exists j \in \{1,...,5\}: s_{j|4} = 1 \mand \forall j \in {7,...,10}: s_{j|4} = 0)$
    \item otázka 6, B: \\
      $\forall i \in \{1,...,5\}: (s_{6|2} = 1) \Leftrightarrow (\exists j \in \{7,...,10\}: s_{j|4} = 1 \mand \forall j \in {1,...,5}: s_{j|4} = 0)$
    \item otázka 6, C: \\
      $\forall i \in \{1,...,5\}: (s_{6|3} = 1) \Leftrightarrow (\exists j \in \{1,...,5,7,...,10\}: s_{j|4} = 1)$
    \item otázka 6, D: \\
      $\forall i \in \{1,...,5\}: (s_{6|4} = 1) \Leftrightarrow (\forall j \in \{1,...,10\}: s_{j|4} = 0)$
    \item otázka 6, E: \\
      $\forall i \in \{1,...,5\}: (s_{6|5} = 1) \Leftrightarrow (s_{6|4} = 1)$
    \item otázka 7: \\
      $\forall i \in \{1,...,5\}: (s_{7|i} = 1) \Leftrightarrow (s_{i+4|5} = 1) \mand ( \forall j \in \{i+4+1...10\}: s_{j,5} = 0 ) )$
    \item otázka 8: \\
      $\forall i \in \{1,...,5\}: (s_{8|i} = 1) \Leftrightarrow \left(\sum_{j=1}^{10}{\left(s_{j|2} + s_{j|3} + s_{j|4}\right)} = 7-i+1 \right)$
    \item otázka 9: \\
      $\forall i \in \{1,...,5\}: (s_{0|i} = 1) \Leftrightarrow \left(\sum_{j=1}^{10}{\left(s_{j|1} + s_{j|5}\right)} = i-1 \right)$. 
   \end{itemize}
	\end{itemize}
The Essence implementation is in figure \ref{benchmark-essence:srq}.

\begin{figure}
\caption{\label{benchmark-essence:srq}Implementation of Self Referential Quiz in Essence}
\begin{lstlisting}
language ESSENCE' 1.b.a
find s : matrix indexed by [int(1..10), int(1..5)] of bool
such that
$ the is only one answer to each question and there is not any unanswered question
 forall row : int(1..10). ((sum col : int(1..5). s[row,col]) = 1),
$ Question 1
$ A to D
  forall col : int(1..4). ( (s[1,col] = 1) <=> ( (s[(4-col+1),1] = 1) /\ ( forall row : int(1..(4-col)). (s[row,1] = 0) ) ) ),
$ E
  (s[1,5] = 1) <=> (forall row : int(1..4). (s[row,1] = 0)),

$ Question 2
  forall col : int(1..5). ( (s[2,col] = 1) <=> ( forall col2: int(1..5). (s[3+col-1,col2] = s[3+col,col2]) ) ),
$ Question 3
  forall col : int(1..5). ( (s[3,col] = 1) <=> ( (s[(4+col-1),1] = 1) /\ ( forall row : int (4..2+col). s[row,1] = 0 ) ) ),
$ Question 4
  forall col : int(1..5). ( (s[4,col] = 1) <=> ( (s[col*2,2] = 1) /\ ( forall row : int(1..(col-1)). s[row*2,2] = 0 ) ) ),
$ Question 5
  forall col : int(1..5). ( (s[5,col] = 1) <=> (s[2*col-1,3]=1) ),
$ Question 6
  (s[6,1] = 1) <=> ( ( exists row : int(1..5). s[row,4] = 1 ) /\ ( forall row : int (7..10). s[row,4] = 0 ) ),
  (s[6,2] = 1) <=> ( ( exists row : int(7..10). s[row,4] = 1 ) /\ ( forall row : int (1..5). s[row,4] = 0 ) ),
  (s[6,3] = 1) <=> ( ( exists row : int(7..10). s[row,4] = 1 ) /\ ( exists row : int (1..5). s[row,4] = 1 ) ),
  (s[6,4] = 1) <=> ( forall row : int (1..10). s[row,4] = 0 ),
  (s[6,5] = 1) <=> (s[6,4] = 1),
$ Question 7
  forall col : int(1..5). ( (s[7,col] = 1) <=> ( (s[col+4,5] = 1) /\ ( forall row : int (col+4+1..10). s[row,5] = 0 ) ) ),
$ Question 8
  forall col: int(1..5). ( (s[8,col] = 1) <=> ( ( sum row: int(1..10). (s[row,2] + s[row,3] + s[row,4]) ) = (7-col+1) ) ),
$ Question 9
  forall col: int(1..5). ( (s[9,col] = 1) <=> ( ( sum row: int(1..10). (s[row,1] + s[row,5]) ) = (col-1) ) )
$ Constraints for question 10 are useless
\end{lstlisting} 
\end{figure}

\section{Quasigroup with holes}
Kvazigrupa neboli latinský ètverec je tabulka o velikosti $n \times n$ vyplnìná 
èísly v rozsahu $0-n$ tak, ¾e se ¾ádné èíslo v øádku ani ve sloupci neopakuje. 
Je mo¾né zadat i dodateènou podmínku na prvky kvazigrupy, napøíklad, ¾e prvky 
na diagonále musí být sudé apod. Úkolem je pak pro danou èásteènì vyplnìnou 
kvazigrupu najít zbylé prvky tak, aby byla plnì vyplnìna a splòovala v¹echny 
podmínky na ní kladené. Takovéto zadání se nazývá problém doplnìní 
kvazigrupy -- quasigroup completion problem (QCP). Bohu¾el toto nemusí vést v¾dy 
ke stejným výsledkùm. Nìkterá zadání toti¾ není mo¾né splnit, nìkterá jsou pøekvapivì 
jednoduchá apod. Navíc je úloha zaplnìní latinského ètverce NP-úplná, nemù¾eme si 
tedy být nikdy jistí, zda je problém pouze moc nároèný pro øe¹iè a nebo zda øe¹iè nedává 
odpovìï proto, ¾e øe¹ení neexistuje. Proto se místo klasického QCP pou¾ívá jeho 
modifikace -- kvazigrupa s dírami (QWH). Nejprve si pøedem vygenerujeme kvazigrupu, 
která splòuje danou podmínku. Pak z této kvazigrupy odstraníme nìkteré hodnoty, 
které pak necháme dopoèítat solver. Tím máme zaruèeno, ¾e øe¹ení existuje. Generováním 
vhodných zadání pro QWH se zabýval D. Achlioptas a kol., kteøí ukázali, ¾e tì¾kost 
problému souvisí s tzv. páteøí \cite{Achlioptas00generatingsatisfiable}. Páteø 
je mno¾ina prvkù kvazigrupy, které se vyskytují ve v¹ech øe¹eních. Pokud se podíl 
páteøe blí¾í k $0 \%$, znamená to, ¾e exiustuje mnoho rùzných øe¹ení a tedy øe¹iè 
mù¾e nìjaké øe¹ení najít "náhodou". Pokud je oproti tomu podíl páteøe blízký 
 $100 \%$, existuje velmi málo øe¹ení a vedou k nìmu v¹echny podmínky. Dá se tedy 
 oèekávat, ¾e zajímavé kvazigrupy budou takové, jejich¾ páteø má podíl okolo $50 \%$. 
 Experimenty pak prokázaly \cite{Achlioptas00generatingsatisfiable}, ¾e nejnároènìj¹í 
 jsou problémy s podílem páteøe mezi 30 a $35 \%$.
 
My pou¾ijeme kvazigrupy bez dodateèné podmínky na prvky, které si vygenerujeme 
pomocí programù lsencode od Carly Gomezové [citace? odkaz?] a walksat od Henryho 
Kautze.

\subsection{Model CSP}
Model pro kvazigrupu øádu $n$. Pøedvyplnìné hodnoty jsou v poli $\mathrm{data}_{ij}$:

\begin{itemize}
	\item Promìnné a domény: $q_{11}, ..., q_{nn} \in \left\{1, ..., n\right\}$.
	\item Podmínky:
	 \begin{itemize}
    	\item Prvky v jednom øádku jsou rùzné: $\forall i \in \left\{1, ..., n\right\}: \forall j,k \in \left\{1, ..., n\right\}: q_{ij} \neq q_{ik}$, 
    	\item prvky v jednom sloupci jsou rùzné: $\forall i \in {1, ..., n}: \forall j,k \in {1, ..., n}: q_{ji} \neq q_{ki}$ 
    	\item nìkteré prvky mají hodnotu danou zadáním: $\mathrm{data}_{ij} \textnormal{ definováno } \Leftrightarrow (q_{ij} = \mathrm{data}_{ij})$
	 \end{itemize}
\end{itemize}
The Essence implementation is in figure \ref{benchmark-essence:qwh}.

\begin{figure}
\caption{\label{benchmark-essence:qwh}Implementation of Quasigroup With Holes Problem in Essence}
\begin{lstlisting}
language ESSENCE' 1.b.a
letting nDomain be domain int(1..n)
find qcp : matrix indexed by [nDomain,nDomain] of nDomain
such that
  forall i : nDomain. alldiff(qcp[i, nDomain]),
  forall i : nDomain. alldiff(qcp[nDomain,i])
\end{lstlisting} 
\end{figure}

\section{Výstavba skladù}
Pøedstavme si, ¾e máme hypotetické obchodní spoleènosti pomoci s rozhodnutím, 
jaké postavit sklady pro své prodejny. Hlavním kritériem je samozøejmì cena, jakou 
bude tato výstavba stát. Na¹ím cílem je tedy tuto cenu minimalizovat. Na druhou 
stranu musíme vyhovìt v¹em omezujícím podmínkám, na problém kladených. Spoleènost 
má ji¾ postavené prodejny a vytipované lokality pro své sklady. Ka¾dý mo¾ný sklad 
má definovanou svou maximální kapacitu -- nejvy¹¹í mo¾ný poèet obsluhovaných obchodù. 
Ka¾dý obchod musí mít pøidìlený právì jeden sklad. Cena za výstavbu skladu je fixní 
ale náklady na zásobení prodejny z daného skladu je pro ka¾dou takovou dvojici 
rùzná. Øe¹iè na zaèátku dostane jako zadání poèet prodejen, poèet mo¾ných skladù 
s jejich kapacitami a matici c, kde prvek cij urèuje cenu za zásobování prodejny
 $i$ ze skladu $j$.

\subsection{Model CSP}
Máme k dispozici $W$ skladù, pøièem¾ otevøení ka¾dého skladu stojí $\mathrm{openCost}$.
Dále máme $S$ prodejen. Máme danou maximální kapacitu skladu $w$, kde $w_i$ je 
maximální poèet prodejen, které mohou odebírat zbo¾í od skladu $i \in \{1,...,W\}$.
Nakonec máme zadanou cenu $\mathrm{supplyCost}$ dopravy zbo¾í tak, ¾e $\mathrm{supplyCost}_{ij}$ 
znamená cenu dopravy ze skladu $i$ do prodejny $j$.

	\begin{itemize}
  \item Promìnné a domény:
    \begin{itemize}
      \item Celková cena -- hodnota objektivní funkce: $\mathrm{totalCost} \in \mathbb{N} $,
      \item poèet otevøených skladù: $\mathrm{numberOpen} \in \{0, W\}$,
      \item indikace, zda je sklad otevøen: $\mathrm{open}_1, ..., \mathrm{open}_{W} \in \{0, 1\}$,
      \item indikace který sklad zásobuje kterou prodejnu: $\mathrm{supplier}_1, ..., \mathrm{supplier}_{S} \in \{1, ..., W\}$,
      \item pomocná promìnná indikující cenu dopravy do prodejny: $\mathrm{cost}_1, ..., \mathrm{cost}_{S} \in \mathbb{N}$,
      \item celková cena za dopravu: $\mathrm{costSum} \in \mathbb{N}$.
    \end{itemize} 
	\item Podmínky:
  	\begin{itemize}
  	 \item Objektivní funkce: $\mathrm{totalCost} = \mathrm{costSum} + \mathrm{numberOpen} \cdot \mathrm{openCost}$,
  	 \item celková cena za dopravu: $\mathrm{costSum} = \sum_i{\mathrm{cost}_i}$,
  	 \item poèet otevøených skladù: $\mathrm{numberOpen} = \sum_i{\mathrm{open}_i}$,
  	 \item kapacita skladu nesmí být pøekroèena: $\forall i \in \{1,...,W\}: w_i \geq \sum_{\mathrm{supplier}_j = i}{1}$,
  	 \item pokud sklad dodává do nìjaké prodejny, je otevøený: $\forall i \in \{1,...,W\}: \left(\mathrm{open} = 1\right) \Leftrightarrow \left(\left(\sum_{\mathrm{supplier}_j = i}{1}\right) > 0\right)$,
  	 \item cena za dopravu ze skladu do prodejny: $\forall i \in {1,...,S}, \forall j \in \{1,...,W\}: \left(\mathrm{supplier}_i = j\right) \Rightarrow \left(\mathrm{cost}_1 = \mathrm{supplyCost}_{ij} \right)$.
     
     %$ \sum_{w \textnormal{ is open}}\left(c+\sum_{s \textnormal{ is suplied by } w} \mathrm{SC}(s,w) \right)$
    \end{itemize}
  \end{itemize} 
The Essence implementation is in figure \ref{benchmark-essence:lw}.

\begin{figure}
\caption{\label{benchmark-essence:lw}Implementation of Locating Warehouses Problem in Essence}
\begin{lstlisting}
language ESSENCE' 1.b.a

given Capacity : matrix indexed by [WarehousesRANGE] of int(0..numberOfStores)
given StoreWarehouseCost : matrix indexed by [StoresRANGE,WarehousesRANGE] of CostRANGE
letting CostRANGE be domain int(0..maxCost)
letting StoresRANGE be domain int(0..numberOfStores-1)
letting WarehousesRANGE be domain int(0..numberOfWarehouses-1)

find 
  TotalCost : CostRANGE,
  Open : matrix indexed by [WarehousesRANGE] of int(0..1),
  NumberOpen : int(0..numberOfWarehouses),
  Supplier : matrix indexed by [StoresRANGE] of WarehousesRANGE,
  Cost : matrix indexed by [StoresRANGE] of CostRANGE,
  SumCost : CostRANGE
  
minimising TotalCost

such that
  TotalCost = SumCost + NumberOpen * warehouseCost,
  SumCost = sum j : StoresRANGE. (Cost[j]),
  NumberOpen = sum j : WarehousesRANGE. (Open[j]),

  forall i : WarehousesRANGE.  
	(Capacity[i] >= (sum j : StoresRANGE. (Supplier[j] = i))),

  forall i : WarehousesRANGE.  
	(((sum j : StoresRANGE. (Supplier[j] = i)) > 0) => (Open[i] = 1) ),

  forall i : WarehousesRANGE.  
	(((sum j : StoresRANGE. (Supplier[j] = i)) = 0) => (Open[i] = 0) ),
  
  forall i : StoresRANGE. forall j : WarehousesRANGE. ( (Supplier[i] = j) => (Cost[i] = StoreWarehouseCost[i,j]) )
\end{lstlisting}
\end{figure}