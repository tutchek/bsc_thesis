\chapter{Benchmarks}
\verb= $Id$ =

In this chapter we define the benchmarks which are used to test features of each 
solver. It is five problems which are well known and documented. N-queens problem,
magic sequence problem, self refferential quiz, quasigroup with holes problem and 
locating warehouses problem. Further description of these benchmark is in the rest of
this chapter. We show on them the different ways how the solvers model the problems. 
Also we measure time and memory amount needed to compute the solutions of the benchmark 
problems. Except the self refferential quiz all of the presented problems can be scaled
and can be used to test the robustness of the solver. We test the robustness on the 
magic sequence problem. We define the robustness of the solver as the length of
the longest magic sequence which can be computed in the selected solver in a given 
amount of time. The last benchmark problem -- locating warehouses -- is an optimalistion
problem. The solver not only has to find correct solution but also the best of such 
solutions based on the value of the objective function. For each benchmart we present 
its general description, formal model of the constraint problem and implementation in
the Essence  programming language. The language basics are described in the following 
section.

\section{Essence}
Essence  is a programming language for modelling of combinatorial problems. Is is 
sufficiently easy to understand and simple that even person who has never seen the
language can corretly guess what is the program supposed to do. Program in Essence 
consists of three parts. The first part defines version of the language, the second
part used variables and finally the third part the used constraints on the given 
variables. The constrained variables can be integers, booleans and vectors or matrices.
The language supports sums and loops over the variables; however, the bounds of the
sum or loop have to be constant because it is in the process of compilig translated
to a sequence of statements. The program can be split into the model definition
and parameters definition parts. Examples in this chapters shows only the model 
definition parts. The parameter definition files can be found on the included CD.
As a compiler from the Essence language to solver specific language the Tailor tool
is available. In the current version it can tranlaste the Essence program to Minion 
input file, FlatZinc and C++ source code using Gecode library. Further description of
the Tailor system is in section \ref{tailor}.

\section{N-queens}
This benchmark is based on a classic chess task. The player have to place eight queens
on the chessboard in a way that none of the queens offends any other. The task
can be generalised on chessboard of any size. The goal is then place $n$ queens to
the table of size $n \times n$ in a way that no queen offends any other. The queen
offend all pieces which are placed in the same row, column and diagonal on the chessboard.
The problem is little bit easier if we find out that if we want to place $n$ queens
on the chessboard with $n$ columns, there have to be one queen per column. Therefore 
we need only to find out which in which row is the queen in each column. We model the
solution of problem as a vector $q_i$ where $i \in \{1,...,n\}$. To avoid
placing the queens on the same row we simply add constraint that all $q_i$ are 
different. Finally we hve to handle the diagonals. Two pieces are on the same diagonal 
if the difference in the horizontal and vertical coordinates is equal. Therefore we 
add the constraint $\left|Q(i) - Q(j)\right| \neq \left|i - j\right|$.
Since the chessboard and queens effect are symmetric also the solutions are symmetric.
We can cut down the number of solutions if we avoid such symmetries.

\subsection{Constraint problem model}
\begin{itemize}
	\item Variables and domains: 
    \begin{itemize}
      \item Positions of queens: $q_1, ..., q_n \in \left\{1, ..., n \right\}$, $q_i$.
    \end{itemize}
	\item Constraints:
    \begin{itemize}
     \item All queens are on different rows: $\forall i,j \in \left\{1, ..., n\right\}: q_i \neq q_j$,
	   \item all queens are on different diagonals: $\forall i,j \in \left\{1, ..., n\right\}: |q_i - q_j| \neq |i - j|$
	   \item optional avoiding of the symmetry: $q_1 < q_n$
	  \end{itemize}
\end{itemize}
The Essence implementation is in figure \ref{benchmark-essence:nqueens}.

\begin{figure}
\caption{\label{benchmark-essence:nqueens}Implementation of N-Queens Problem in Essence}
\begin{lstlisting}
language ESSENCE' 1.b.a
find queens: matrix indexed by [int(1..n)] of int(1..n)
such that

alldiff(queens),  
forall i: int(1..n). forall j: int(i+1..n).
| queens[i] - queens[j] | != | i - j |
\end{lstlisting} 
\end{figure}

\begin{figure}[ht]
\caption{\label{4queens-solution}Solutions of 4-queens problem}
\begin{center}
\begin{tabular}{cc}
\def\mylist{Qa3,Qb1,Qc4,Qd2}
\setchessboard{setpieces=\mylist,showmover=false,
		pgfstyle=straightmove,
		markmove=c4-a4, %Qc4
		markmove=c4-a2,
		markmove=c4-c1,
		markmove=c4-d3,
		markmove=c4-d4}
\def\mylist{Qa3,Qb1,Qc4,Qd2}
\chessboard[maxfield=d4] & \def\mylist{Qa2,Qb4,Qc1,Qd3}
\setchessboard{setpieces=\mylist,showmover=false}
\def\mylist{Qa2,Qb4,Qc1,Qd3}
\chessboard[maxfield=d4]
\end{tabular}
\end{center}
\end{figure}

\section{Magic sequence}
\label{magic-sequence}
Magic sequence of length $n$ is a sequence $m_i$, $i \in \{0,...,n-1\}$ of numbers 
which satisfies the following condition: The value of $m_k$ is equal to the
number of occurences of value $k$ in sequence. For example the sequence $(2\, 1\, 2\, 0\, 0)$
is magic sequence of length five because the condition is satisfied. The number zero
is twice in the sequence and $m_0$ is equal to two. Simillary one is in the sequence only
once and therefore $m_1$ is one, and so on.

\subsection{Constraint problem model}
Model for a magic sequence $m$ of length $k$:

\begin{itemize}
	\item Variables and domains: 
    \begin{itemize}
      \item Magic sequence items: $m_0, ..., m_{k-1} \in  \left\{0, ..., k\right\}$.
    \end{itemize}
	\item Constraints:
	 \begin{itemize}
      \item Value of $m_i$ is $i$ times in the sequence: $\forall i \in 
      {0,...,k-1}: m_i = \sum_{m_j = 1}{1}$.
    \end{itemize}
\end{itemize}
  
In case that solver does not support the constraint $m_i = \sum_{m_j = 1}{1}$, we 
can use an alternative model: 

\begin{itemize}
	\item Values and domains:
  \begin{itemize} 
	 \item Magic sequence items: $m_0, ..., m_{k-1} \in \left\{0, ..., k\right\}$,
	 \item auxiliary variables: $\forall i,j \in {0, ..., k-1}: \mathrm{aux}_{ij}$.
	\end{itemize}
	\item Constraints:
	 \begin{itemize}
    \item $\mathrm{aux}_{ij} = 1$ if and only if $m_j = 0$: $\forall i,j \in \left\{0, ..., k-1\right\}: 
          (\mathrm{aux}_{ij} = 1) \Leftrightarrow (m_j = i)$,
	  \item the value of the items of the magic sequence corresponds to the sum of some auxiliary variables: 
          $\forall i \in \left\{0, ..., k-1\right\}: m_i = \sum_{j=0}^{k-1}{\mathrm{aux}_{ij}}$.
    \end{itemize}
\end{itemize}
The Essence implementation is in figure \ref{benchmark-essence:mseq}.

\begin{figure}
\caption{\label{benchmark-essence:mseq}Implementation of Magic Sequence Problem in Essence}
\begin{lstlisting}
language ESSENCE' 1.b.a
find s : matrix indexed by [int(0..n-1)] of int(0..n)
such that
  forall i : int(0..n-1).
        ( s[i] = (sum j : int(0..n-1). (s[j] = i)))
\end{lstlisting} 
\end{figure}

\section{Self-refferential quiz}

Selfrefferential quiz is a quiz where the answers to questions depends on the answers
to other questions in the same quiz. There is only one answer valid for each question.
Typical question in such quiz can be: 

\begin{enumerate}
  \item First question whose anser is $A$ is: \\
    (A) 1 (B) 2 (C) 3 (D) 4 (E) there is no question with answer A
  \item Answer to thiss question is: \\ 
    (A) A (B) B (C) C (D) D (E) E
\end{enumerate}

these quizes are best modelled using rified constraints. Reified constraint is a constraint
in form $(C \Leftrightarrow x) \& x \in \left\{0,1\right\}$. The ways how to construct
such quizes are described in the article by Maja Bubalo \cite{jios:bubalo}.
The quiz assignment follows:

\begin{enumerate}
	\item The first question whose answer is A is:\\
		(A) 4 (B) 3 (C) 2 (D) 1 (E) none of above
	\item The only two consecutive questions with identical answers are: \\
		(A) 3 and 4 (B) 4 and 5 (C) 5 and 6 (D) 6 and 7 (E) 7 and 8
	\item The next question with answer A is: \\
		(A) 4 (B) 5 (C) 6 (D) 7 (E) 8
	\item The first even numbered question with answer B is: \\
		(A) 2 (B) 4 (C) 6 (D) 8 (E) 10 
	\item The only odd numbered question with answer C is: \\
		(A) 1 (B) 3 (C) 5 (D) 7 (E) 9
	\item A question with answer D: \\
		(A) comes before this one, but not after this one (B) comes after this one, but not before this one (C) comes before and after this one (D) does not occur at all (E) none of the above
	\item The last question whose answer is E is: \\
		(A) 5 (B) 6 (C) 7 (D) 8 (E) 9
	\item The number of questions whose answers are consonants is: \\
		(A) 7 (B) 6 (C) 5 (D) 4 (E) 3
	\item The number of questions whose answers are vowels is: \\
		(A) 0 (B) 1 (C) 2 (D) 3 (E) 4
	\item The answer to this question is: \\
		(A) A (B) B (C) C (D) D (E) E
\end{enumerate}

We model the quiz as a table of boolean variables with five columns (A,B,C,D,E) 
and ten rows, one for each question. The value in the column $i$ and row $j$ is
{\em true} if and only if the answer to question $j$ is $i$. Because there is only one
answer possible to all questions we constraint the rows of the table to contain
only one {\em true}. The test has only one solution showed in figure \ref{srq-solution-table}. 
 
\begin{table}[ht]
\caption{\label{srq-solution-table}Solution of Self Referential Quiz}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|}
\hline Question & A & B & C & D & E \\
\hline\hline 1 & 0 & 0 & 1 & 0 & 0 \\
\hline 2 & 1 & 0 & 0 & 0 & 0 \\
\hline 3 & 0 & 1 & 0 & 0 & 0 \\
\hline 4 & 0 & 1 & 0 & 0 & 0 \\
\hline 5 & 1 & 0 & 0 & 0 & 0 \\
\hline 6 & 0 & 1 & 0 & 0 & 0 \\
\hline 7 & 0 & 0 & 0 & 0 & 1 \\
\hline 8 & 0 & 1 & 0 & 0 & 0 \\
\hline 9 & 0 & 0 & 0 & 0 & 1 \\
\hline 10 & 0 & 0 & 0 & 1 & 0 \\
\hline 
\end{tabular}
\end{center}
\end{table}

\subsection{Constraint problem model}
	\begin{itemize}
  \item Variables and domains: 
    \begin{itemize}
      \item Answer to the questions: $s_{1|1}, s_{1|2}, ..., s_{10|4}, s_{10|5} \in {0, 1}$.
    \end{itemize}
	\item Podmínky:
	 \begin{itemize}
    \item There is exactly one value 1 in the row: \\
      $\forall i \in \{1, \ldots, 10\}: \left(\sum_{j \in \{1, ..., 5\}}{s_{i|j}}\right) = 1$,
    \item question 1, A to D: \\
      $\forall i \in \{1,...,4\}: (s_{1|i} = 1) \Leftrightarrow (s_{4-i+1|1} = 1 \mand (\forall j \in \{1,...,4-1\}: s_{j|1} = 0))$,
    \item question 1, E: \\
      $(s_{1|5} = 1) \Leftrightarrow (\forall j \in \{1,...,4\}: s_{j|1} = 0)$,
    \item question 2: \\
      $\forall i \in \{1,...,5\}: (s_{2|i} = 1) \Leftrightarrow (\forall j \in \{1,...,5\}: s_{(3+i-1)|j} = s_{3+i|j})$,
    \item question 3: \\
      $\forall i \in \{1,...,5\}: (s_{3|i} = 1) \Leftrightarrow (s_{4+i-1|1} = 1 \mand (\forall j \in \{4..2+i\}: s_{j|1} = 0 ) )$,
    \item question 4: \\
      $\forall i \in \{1,...,5\}: (s_{4|i} = 1) \Leftrightarrow (s_{2i|2} = 1 /\ ( \forall j \in \{1..i-1\}: s_{2j|2} = 0 )$,
    \item question 5: \\
      $\forall i \in \{1,...,5\}: (s_{5|i} = 1) \Leftrightarrow (s_{2i-1|3}=1)$
    \item question 6, A: \\
      $\forall i \in \{1,...,5\}: (s_{6|1} = 1) \Leftrightarrow (\exists j \in \{1,...,5\}: s_{j|4} = 1 \mand \forall j \in {7,...,10}: s_{j|4} = 0)$
    \item question 6, B: \\
      $\forall i \in \{1,...,5\}: (s_{6|2} = 1) \Leftrightarrow (\exists j \in \{7,...,10\}: s_{j|4} = 1 \mand \forall j \in {1,...,5}: s_{j|4} = 0)$
    \item question 6, C: \\
      $\forall i \in \{1,...,5\}: (s_{6|3} = 1) \Leftrightarrow (\exists j \in \{1,...,5,7,...,10\}: s_{j|4} = 1)$
    \item question 6, D: \\
      $\forall i \in \{1,...,5\}: (s_{6|4} = 1) \Leftrightarrow (\forall j \in \{1,...,10\}: s_{j|4} = 0)$
    \item question 6, E: \\
      $\forall i \in \{1,...,5\}: (s_{6|5} = 1) \Leftrightarrow (s_{6|4} = 1)$
    \item question 7: \\
      $\forall i \in \{1,...,5\}: (s_{7|i} = 1) \Leftrightarrow (s_{i+4|5} = 1) \mand ( \forall j \in \{i+4+1...10\}: s_{j,5} = 0 ) )$
    \item question 8: \\
      $\forall i \in \{1,...,5\}: (s_{8|i} = 1) \Leftrightarrow \left(\sum_{j=1}^{10}{\left(s_{j|2} + s_{j|3} + s_{j|4}\right)} = 7-i+1 \right)$
    \item question 9: \\
      $\forall i \in \{1,...,5\}: (s_{0|i} = 1) \Leftrightarrow \left(\sum_{j=1}^{10}{\left(s_{j|1} + s_{j|5}\right)} = i-1 \right)$. 
   \end{itemize}
	\end{itemize}
The Essence implementation is in figure \ref{benchmark-essence:srq}.

\begin{figure}
\caption{\label{benchmark-essence:srq}Implementation of Self Referential Quiz in Essence}
\begin{lstlisting}
language ESSENCE' 1.b.a
find s : matrix indexed by [int(1..10), int(1..5)] of bool
such that
$ the is only one answer to each question and there is not any unanswered question
 forall row : int(1..10). ((sum col : int(1..5). s[row,col]) = 1),
$ Question 1
$ A to D
  forall col : int(1..4). ( (s[1,col] = 1) <=> ( (s[(4-col+1),1] = 1) /\ ( forall row : int(1..(4-col)). (s[row,1] = 0) ) ) ),
$ E
  (s[1,5] = 1) <=> (forall row : int(1..4). (s[row,1] = 0)),

$ Question 2
  forall col : int(1..5). ( (s[2,col] = 1) <=> ( forall col2: int(1..5). (s[3+col-1,col2] = s[3+col,col2]) ) ),
$ Question 3
  forall col : int(1..5). ( (s[3,col] = 1) <=> ( (s[(4+col-1),1] = 1) /\ ( forall row : int (4..2+col). s[row,1] = 0 ) ) ),
$ Question 4
  forall col : int(1..5). ( (s[4,col] = 1) <=> ( (s[col*2,2] = 1) /\ ( forall row : int(1..(col-1)). s[row*2,2] = 0 ) ) ),
$ Question 5
  forall col : int(1..5). ( (s[5,col] = 1) <=> (s[2*col-1,3]=1) ),
$ Question 6
  (s[6,1] = 1) <=> ( ( exists row : int(1..5). s[row,4] = 1 ) /\ ( forall row : int (7..10). s[row,4] = 0 ) ),
  (s[6,2] = 1) <=> ( ( exists row : int(7..10). s[row,4] = 1 ) /\ ( forall row : int (1..5). s[row,4] = 0 ) ),
  (s[6,3] = 1) <=> ( ( exists row : int(7..10). s[row,4] = 1 ) /\ ( exists row : int (1..5). s[row,4] = 1 ) ),
  (s[6,4] = 1) <=> ( forall row : int (1..10). s[row,4] = 0 ),
  (s[6,5] = 1) <=> (s[6,4] = 1),
$ Question 7
  forall col : int(1..5). ( (s[7,col] = 1) <=> ( (s[col+4,5] = 1) /\ ( forall row : int (col+4+1..10). s[row,5] = 0 ) ) ),
$ Question 8
  forall col: int(1..5). ( (s[8,col] = 1) <=> ( ( sum row: int(1..10). (s[row,2] + s[row,3] + s[row,4]) ) = (7-col+1) ) ),
$ Question 9
  forall col: int(1..5). ( (s[9,col] = 1) <=> ( ( sum row: int(1..10). (s[row,1] + s[row,5]) ) = (col-1) ) )
$ Constraints for question 10 are useless
\end{lstlisting} 
\end{figure}

\section{Quasigroup with holes}
Quasigroup or latin square is a table of size $n \times n$ filled with numers in
range $1..n$ such that all values in each row and in each column are unique. There
can be also additional condition on the items of quasigroup, for example that the 
items on the main diagonal have to be even and so on. The task is to fully fill the 
given partly filled quasigroup. The completed quasigroup have to satisfy all previously
stated constraints. This problem is called {\em quasigroup completion problem} or QCP.
Unfortunately this benchmark does not provide allways the same results. Some partial fillings
can be solved surprisingly easily, some on the other hand can be extremly hard and 
some can even be unsolvable. The problem is that determining if the assignment can
be satisfied of not is a NP-hard task. Therefore we cannot be sure if the problem is only
too hard for the solver or if the solution does not exist and the solvver has to search 
through the enormous state space. To avoid this uncertainity we use the modification of
QCP called {\em quasigroup with holes} or QWH. First we generate fully filled quasigroup
which satisfies the given conditions, then we drop some values and this quasigroup
with holes is the assignment for QCP. We have guarantee that the assignment is correct
and can be solved. The generating of proper QWH assignments was studied by D. Achlioptas
et al. They found out that the hardness of the problem coincide with the size of 
so called backbone \cite{Achlioptas00generatingsatisfiable}. Backbone is a set 
of positions in the quasigroup which have the same value in all solutions.
If the size of backbone is close to $0 \%$, there are many different solutions and
the solver can find some "by accident". On the other hand if the backbone is close
to $100 \%$, there is only one solution and all constraints leads towards to it.
We can therefore expect interesting behavior with the backbone of the size $50 \%$,
The experiments \cite{Achlioptas00generatingsatisfiable} showed that this interesting 
behavior is somewhere near the $30 \%$.

We use the quasigroups with no additional conditions. The used quasigroups are generated
by the generators {\em lsencode} by Carla Gomez and {\em walksat} by Henry Kautz. 
 
\subsection{Constraint problem model}
Model quasigroup of order $n$. Assignment values are in the vector $\mathrm{data}_{ij}$:

\begin{itemize}
	\item Variables and domains: 
    \begin{itemize}
      \item Quasigroup items: $q_{11}, ..., q_{nn} \in \left\{1, ..., n\right\}$.
    \end{itemize}
	\item Podmínky:
	 \begin{itemize}
    	\item All items in one rows are unique: $\forall i \in \left\{1, ..., n\right\}: \forall j,k \in \left\{1, ..., n\right\}: q_{ij} \neq q_{ik}$, 
    	\item all items in one column are unique: $\forall i \in {1, ..., n}: \forall j,k \in {1, ..., n}: q_{ji} \neq q_{ki}$ 
    	\item some items of quasigroup are preassigned: $\mathrm{data}_{ij} \textnormal{ definováno } \Leftrightarrow (q_{ij} = \mathrm{data}_{ij})$
	 \end{itemize}
\end{itemize}
The Essence implementation is in figure \ref{benchmark-essence:qwh}.

\begin{figure}
\caption{\label{benchmark-essence:qwh}Implementation of Quasigroup With Holes Problem in Essence}
\begin{lstlisting}
language ESSENCE' 1.b.a
letting nDomain be domain int(1..n)
find qcp : matrix indexed by [nDomain,nDomain] of nDomain
such that
  forall i : nDomain. alldiff(qcp[i, nDomain]),
  forall i : nDomain. alldiff(qcp[nDomain,i])
\end{lstlisting} 
\end{figure}

\section{Locating warehouses}
Let assume that we want to help the hypothetical business company with decision which
warehouses shoud be built for their stores and which warehouse should supply which
store. The main criteria is of course the cost of the solution. The cost has two component. One
is a fixed fee for opening a new store. The second is the price for distribution of
goods from warehouse to store. The price vary and is different for all pairs (warehouse, store). 
Each possible warehouse has defined the maximal capacity, which means the number
of stores which can be supplied from this warehouse. As a last condition we need to
supply all stores. Our task is to choose the solution with minimal total cost.

The solver takes as an input parameter maximal cappacities of warehouses, table with
prices of supplying for each pair (warehouse, store) and computes the vector
 $s_i$, $i \in \{1,...,\#\mathrm{ of stores}\}$ where $s_i$ indicates which warehouse
 supplies the store $i$.

\subsection{Model CSP}
We can build $W$ warehouses. The price for opening of a new warehouse is fixed and 
stored in parameter $\mathrm{openCost}$. We have also $S$ stores. The maximal capacity
of warehouses is given as vector $w$, where $w_i$ is maximal number of stores, which
can be supplied by the warehouse $i$, $i \in \{1,...,W\}$.
Finally we have the matrix of supply costs $\mathrm{supplyCost}$ where $\mathrm{supplyCost}_{ij}$ 
means cost of supplying the store $j$ from warehouse $i$.

	\begin{itemize}
  \item Variables and domains:
    \begin{itemize}
      \item Total cost -- value of objective function: $\mathrm{totalCost} \in \mathbb{N} $,
      \item number of opened stores: $\mathrm{numberOpen} \in \{0, W\}$,
      \item indication whether the store is open: $\mathrm{open}_1, ..., \mathrm{open}_{W} \in \{0, 1\}$,
      \item indication which warehouse supply which store: $\mathrm{supplier}_1, ..., \mathrm{supplier}_{S} \in \{1, ..., W\}$,
      \item indication the supply cost for given store: $\mathrm{cost}_1, ..., \mathrm{cost}_{S} \in \mathbb{N}$,
      \item total supply cost: $\mathrm{costSum} \in \mathbb{N}$.
    \end{itemize} 
	\item Constraints:
  	\begin{itemize}
  	 \item Objective function: $\mathrm{totalCost} = \mathrm{costSum} + \mathrm{numberOpen} \cdot \mathrm{openCost}$,
  	 \item total supply cost: $\mathrm{costSum} = \sum_i{\mathrm{cost}_i}$,
  	 \item number of opened warehouses: $\mathrm{numberOpen} = \sum_i{\mathrm{open}_i}$,
  	 \item maximal capacity of each warehouse: $\forall i \in \{1,...,W\}: w_i \geq \sum_{\mathrm{supplier}_j = i}{1}$,
  	 \item the warehouse is open if it suppply at least one store: $\forall i \in \{1,...,W\}: \left(\mathrm{open}_i = 1\right) \Leftrightarrow \left(\left(\sum_{\mathrm{supplier}_j = i}{1}\right) > 0\right)$,
  	 \item supply cost computation: $\forall i \in {1,...,S}, \forall j \in \{1,...,W\}: \left(\mathrm{supplier}_i = j\right) \Rightarrow \left(\mathrm{cost}_i = \mathrm{supplyCost}_{ij} \right)$.
     
     %$ \sum_{w \textnormal{ is open}}\left(c+\sum_{s \textnormal{ is suplied by } w} \mathrm{SC}(s,w) \right)$
    \end{itemize}
  \end{itemize} 
The Essence implementation is in figure \ref{benchmark-essence:lw}.

\begin{figure}
\caption{\label{benchmark-essence:lw}Implementation of Locating Warehouses Problem in Essence}
\begin{lstlisting}
language ESSENCE' 1.b.a

given Capacity : matrix indexed by [WarehousesRANGE] of int(0..numberOfStores)
given StoreWarehouseCost : matrix indexed by [StoresRANGE,WarehousesRANGE] of CostRANGE
letting CostRANGE be domain int(0..maxCost)
letting StoresRANGE be domain int(0..numberOfStores-1)
letting WarehousesRANGE be domain int(0..numberOfWarehouses-1)

find 
  TotalCost : CostRANGE,
  Open : matrix indexed by [WarehousesRANGE] of int(0..1),
  NumberOpen : int(0..numberOfWarehouses),
  Supplier : matrix indexed by [StoresRANGE] of WarehousesRANGE,
  Cost : matrix indexed by [StoresRANGE] of CostRANGE,
  SumCost : CostRANGE
  
minimising TotalCost

such that
  TotalCost = SumCost + NumberOpen * warehouseCost,
  SumCost = sum j : StoresRANGE. (Cost[j]),
  NumberOpen = sum j : WarehousesRANGE. (Open[j]),

  forall i : WarehousesRANGE.  
	(Capacity[i] >= (sum j : StoresRANGE. (Supplier[j] = i))),

  forall i : WarehousesRANGE.  
	(((sum j : StoresRANGE. (Supplier[j] = i)) > 0) => (Open[i] = 1) ),

  forall i : WarehousesRANGE.  
	(((sum j : StoresRANGE. (Supplier[j] = i)) = 0) => (Open[i] = 0) ),
  
  forall i : StoresRANGE. forall j : WarehousesRANGE. ( (Supplier[i] = j) => (Cost[i] = StoreWarehouseCost[i,j]) )
\end{lstlisting}
\end{figure}